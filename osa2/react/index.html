<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/component---src-templates-content-template-js.bb6688043828bda42216.css">@import url(https://fonts.googleapis.com/css?family=IBM+Plex+Mono:400,500,600);.course{position:relative}.course h1,.course h2,.course h3,.course h4,.course p{margin-left:3rem;padding-bottom:2rem}.course pre{margin:2rem 0;background-color:#33332d;color:#fff}.course img{border:11px solid transparent}.course a{border:0;border-bottom:2px;border-style:solid;border-color:transparent;padding:2px}.course .banner,.course .container{position:static}.course .letter{width:4rem;height:4rem;border-width:5px;border-style:solid;border-radius:2.5rem;text-align:center;margin:1rem;line-height:.8em}@media (min-width:640px){.course .letter{-webkit-transform:translate(-3rem,5rem);transform:translate(-3rem,5rem)}}.course .letter,.course h1{font-size:3.444rem;font-weight:700}.course li{list-style-type:none}.course li:before{content:"-";margin-right:1rem}.arrow__container{position:relative}.arrow__container:not():first-child{border-left:none}.arrow__container:not():first-child:before{content:"";background:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0NzcuMTc1IDQ3Ny4xNzUiPjxwYXRoIGQ9Ik0zNjAuNzMxIDIyOS4wNzVsLTIyNS4xLTIyNS4xYy01LjMtNS4zLTEzLjgtNS4zLTE5LjEgMHMtNS4zIDEzLjggMCAxOS4xbDIxNS41IDIxNS41LTIxNS41IDIxNS41Yy01LjMgNS4zLTUuMyAxMy44IDAgMTkuMSAyLjYgMi42IDYuMSA0IDkuNSA0IDMuNCAwIDYuOS0xLjMgOS41LTRsMjI1LjEtMjI1LjFjNS4zLTUuMiA1LjMtMTMuOC4xLTE5eiIvPjwvc3ZnPg==) no-repeat;background-size:contain;position:absolute;top:0;left:0;height:100%;width:100%}.arrows--horizontal{display:flex;position:relative;margin:0;align-items:flex-start}.arrow__wrapper{display:flex;justify-content:flex-start;align-items:center;margin:0}.arrow__wrapper:first-of-type{border-right:none;z-index:20}.arrow__wrapper:nth-of-type(n+2){margin-left:-4rem;z-index:10}.arrow__wrapper:nth-of-type(n+2) .arrow__rectangle{border-left:none;padding-left:4rem}.arrow__wrapper:nth-of-type(3){z-index:5}.arrow__rectangle{padding:1rem;justify-content:center;align-items:center;border:2px solid #33332d;border-right:none;z-index:2;overflow:hidden}.arrow__rectangle .bold{font-weight:600}.arrow__rectangle--thick-border{border:3px solid #33332d;border-right:none}.arrow__point{padding:1.25rem;border:2px solid #33332d;border-bottom:none;border-left:none;-webkit-transform:translate(-1.3rem) rotate(45deg);transform:translate(-1.3rem) rotate(45deg);z-index:1;overflow:hidden}.arrow__point--thick-border{border:3px solid #33332d;border-bottom:none;border-left:none}.arrow__wrapper--stacked{display:flex;justify-content:flex-start;align-items:center;margin:auto auto auto 0}.arrow__wrapper--stacked:nth-of-type(n+2){margin-top:-2px}.arrow--stacked-letter{margin-right:2rem}.arrow--stacked-title{text-transform:uppercase;white-space:nowrap}.arrow__container--with-link{width:100%!important}.element--flex{display:flex;flex-wrap:wrap}.element--space-around{justify-content:space-around}.element--space-between{justify-content:space-between}.element--column{flex-direction:column}.element--centered{align-items:center}.element--horizontal-half{width:45%}.element--auto-bottom-margin{margin-bottom:auto}.element--flex-start{align-content:flex-start}.banner{display:flex;align-items:center;position:relative;padding:2.22rem 0;background-color:#e1e1e1}@media (min-width:992px){.banner{padding:3.444rem 3.444rem 4.444rem}}html{font-family:IBM Plex Mono,monospace;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:IBM Plex Mono,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{font:112.5%/1.45em IBM Plex Mono,monospace;box-sizing:border-box;overflow-y:scroll}*,:after,:before{box-sizing:inherit}body{color:rgba(0,0,0,.8);font-family:IBM Plex Mono,monospace;font-weight:400;word-wrap:break-word;-webkit-font-kerning:normal;font-kerning:normal;-ms-font-feature-settings:"kern","liga","clig","calt";-webkit-font-feature-settings:"kern","liga","clig","calt";font-feature-settings:"kern","liga","clig","calt"}img{max-width:100%;padding:0;margin:0 0 1.45rem}h1{font-size:2.25rem}h1,h2{padding:0;margin:0 0 1.45rem;color:inherit;font-family:IBM Plex Mono,monospace;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h2{font-size:1.62671rem}h3{font-size:1.38316rem}h3,h4{padding:0;margin:0 0 1.45rem;color:inherit;font-family:IBM Plex Mono,monospace;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h4{font-size:1rem}h5{font-size:.85028rem}h5,h6{padding:0;margin:0 0 1.45rem;color:inherit;font-family:IBM Plex Mono,monospace;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h6{font-size:.78405rem}hgroup{padding:0;margin:0 0 1.45rem}ol,ul{padding:0;margin:0 0 1.45rem 1.45rem;list-style-position:outside;list-style-image:none}dd,dl,figure,p{padding:0;margin:0 0 1.45rem}pre{margin:0 0 1.45rem;font-size:.85rem;line-height:1.42;background:rgba(0,0,0,.04);border-radius:3px;overflow:auto;word-wrap:normal;padding:1.45rem}table{font-size:1rem;line-height:1.45rem;border-collapse:collapse;width:100%}fieldset,table{padding:0;margin:0 0 1.45rem}blockquote{padding:0;margin:0 1.45rem 1.45rem}form,iframe,noscript{padding:0;margin:0 0 1.45rem}hr{padding:0;margin:0 0 calc(1.45rem - 1px);background:rgba(0,0,0,.2);border:none;height:1px}address{padding:0;margin:0 0 1.45rem}b,dt,strong,th{font-weight:700}li{margin-bottom:.725rem}ol li,ul li{padding-left:0}li>ol,li>ul{margin-left:1.45rem;margin-bottom:.725rem;margin-top:.725rem}blockquote :last-child,li :last-child,p :last-child{margin-bottom:0}li>p{margin-bottom:.725rem}code,kbd,samp{font-size:.85rem;line-height:1.45rem}abbr,abbr[title],acronym{border-bottom:1px dotted rgba(0,0,0,.5);cursor:help}abbr[title]{text-decoration:none}td,th,thead{text-align:left}td,th{border-bottom:1px solid rgba(0,0,0,.12);font-feature-settings:"tnum";-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";padding:.725rem .96667rem calc(.725rem - 1px)}td:first-child,th:first-child{padding-left:0}td:last-child,th:last-child{padding-right:0}code,tt{background-color:rgba(0,0,0,.04);border-radius:3px;font-family:SFMono-Regular,Consolas,Roboto Mono,Droid Sans Mono,Liberation Mono,Menlo,Courier,monospace;padding:.2em 0}pre code{background:none;line-height:1.42}code:after,code:before,tt:after,tt:before{letter-spacing:-.2em;content:" "}pre code:after,pre code:before,pre tt:after,pre tt:before{content:""}@media only screen and (max-width:480px){html{font-size:100%}}body,html{margin:0;padding:0;font-family:IBM Plex Mono,monospace;font-weight:500;color:#33332d;font-size:14px;line-height:1.555rem}@media (min-width:992px){body,html{font-size:18px}}body{padding-top:120px}@media (min-width:992px){body{padding-top:90px}}p{margin:0;text-align:left;line-height:1.5em}a,p{color:#33332d}a{text-decoration:none}.container{position:relative;margin:0 auto;display:flex;flex-wrap:wrap;justify-content:space-between;width:90%;max-width:1200px}.hidden{display:none!important}.centered{text-align:center}.spacing{margin-top:2.22rem}@media (min-width:992px){.spacing{margin-top:5.55rem}}.spacing--small{margin-top:1.11rem}@media (min-width:992px){.spacing--small{margin-top:3.444rem}}.spacing--large{margin-top:4.44rem}@media (min-width:992px){.spacing--large{margin-top:11.1rem}}.spacing--extra-large{margin-top:4.44rem}@media (min-width:992px){.spacing--extra-large{margin-top:22.2rem}}.spacing--after{margin-bottom:2.22rem}@media (min-width:992px){.spacing--after{margin-bottom:5.55rem}}.spacing--after-small{margin-bottom:1.11rem}@media (min-width:992px){.spacing--after-small{margin-bottom:2.775rem}}.spacing--after-large{margin-bottom:4.44rem}@media (min-width:992px){.spacing--after-large{margin-bottom:11.1rem}}@media (max-width:991px){.spacing--mobile{margin-top:2.22rem}}.col-1{width:100%}@media (min-width:992px){.col-1{width:10%}}.col-2{width:100%}@media (min-width:992px){.col-2{width:20%}}.col-3{width:100%}@media (min-width:992px){.col-3{width:30%}}.col-4{width:100%}@media (min-width:992px){.col-4{width:40%}}.col-5{width:100%}@media (min-width:992px){.col-5{width:50%}}.col-6{width:100%}@media (min-width:992px){.col-6{width:60%}}.col-7{width:100%}@media (min-width:992px){.col-7{width:70%}}.col-8{width:100%}@media (min-width:992px){.col-8{width:80%}}.col-9{width:100%}@media (min-width:992px){.col-9{width:90%}}.col-10{width:100%}@media (min-width:992px){.col-10{width:100%}}@media (min-width:992px){.push-right-1{margin-left:10%}.push-right-2{margin-left:20%}.push-right-3{margin-left:30%}.push-right-4{margin-left:40%}.push-right-5{margin-left:50%}.push-left-1{margin-right:10%}.push-left-2{margin-right:20%}.push-left-3{margin-right:30%}.push-left-4{margin-right:40%}.push-left-5{margin-right:50%}.push-left{margin-right:auto}.push-right{margin-left:auto}}@media (max-width:991px){.col-5--mobile{width:50%}.col-10--mobile{width:100%}.order-0--mobile{order:0}.order-1--mobile{order:1}.order-2--mobile{order:2}.order-3--mobile{order:3}.order-4--mobile{order:4}.order-5--mobile{order:5}.hidden--mobile{display:none}}.centered-vertically{display:flex;flex-direction:column;justify-content:center}.nav-item-hover{font-size:1.111rem;font-weight:600;text-decoration:none;color:#33332d;padding:.2em}.nav-item-hover:active,.nav-item-hover:focus,.nav-item-hover:hover{color:#fff;background-color:#33332d}.nav-item-hover:active,.nav-item-hover:focus{outline:2px solid #706be4}.flex-fix-aligning:after,.flex-fix-aligning:before{content:"";width:30%;order:2}#footer .nav-item-hover{font-size:.777rem;font-weight:500}.triple-border{margin:5px;position:relative;padding:2px;border-radius:5px 0;transition:color .1s ease-in-out,background-color .1s ease-in-out}.triple-border:after,.triple-border:before{content:"";border:2px solid #33332d;border-radius:5px;position:absolute;width:calc(100% + 5px);height:calc(100% + 5px)}.triple-border:before{left:0;top:0}.triple-border:after{bottom:0;right:0}.triple-border__container{overflow:hidden;border-radius:3px 0}.triple-border--large-margin{margin:13px;padding:3px}.triple-border--large-margin:after,.triple-border--large-margin:before{content:"";border-width:3px;border-radius:13px;width:calc(100% + 13px);height:calc(100% + 13px)}.triple-border--large-margin .triple-border__container{border-radius:10px 0}.triple-border__logo{padding:.2rem;font-size:1.111rem;font-weight:600}.triple-border__return-tasks{font-size:.9rem;padding:1rem .2rem}.body-text:not(:last-of-type){margin-bottom:2.775rem}.body-text__title{color:#33332d;font-size:1.44rem;line-height:1.25em;font-weight:700;margin:0;position:relative;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.body-text__content:not(:last-of-type){padding-bottom:2em}.bold{font-weight:700}.body-text--no-padding{padding:0!important}.scroll-navigation li:hover{cursor:pointer;background-color:#000;color:#fff}.sub-header{color:#33332d;font-family:IBM Plex Mono,monospace;padding-bottom:1.357rem}@media (min-width:992px){.sub-header{padding-bottom:2.333rem}}</style><meta name="generator" content="Gatsby 2.0.53"/><title data-react-helmet="true"></title><link rel="shortcut icon" href="/icons/icon-48x48.png"/><link rel="manifest" href="/manifest.webmanifest"/><meta name="theme-color" content="#663399"/><link as="script" rel="preload" href="/component---src-templates-content-template-js-1511b04e7342894ff772.js"/><link as="script" rel="preload" href="/2-a8e181bf0eaee510a2de.js"/><link as="script" rel="preload" href="/app-e57bcd659185b811abbf.js"/><link as="script" rel="preload" href="/webpack-runtime-d71151d3c956eb7daf5e.js"/><link rel="preload" href="/static/d/364/path---osa-2-react-bb-8-7c8-cgFkJ6TpyvKFqgJNSqfzUWg.json" as="fetch" crossOrigin="use-credentials"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group"><div><div class="container" style="align-items:center"><a style="text-decoration:none" href="/"><div class="triple-border nav-item-hover " style="padding:0.2em"><div class="triple-border__container triple-border__logo" style="background-color:transparent">{() =&gt; fs}</div></div></a><div class="col-4 push-left-4" style="display:flex;justify-content:space-between;font-weight:bold"><a class="nav-item-hover" href="/about">KURSSISTA</a><a class="nav-item-hover" href="/faq">FAQs</a><a class="nav-item-hover" href="/companies">YRITYSESITTELYT</a></div></div><div class="spacing--small spacing--after"><div class="course-container"><div class="banner spacing--after" style="background-image:url(/static/osa2-d6f1547adea77b83d780216137ad3200.png);background-position:center center;background-size:80%;background-repeat:no-repeat;background-color:#EB8755"><div class="container"><div class="col-10 spacing spacing--after"><div class="arrow__container arrows--horizontal"><div class="arrow__wrapper "><div class="arrow__rectangle  " style="background-color:#EB8755;color:black">YLEISTÄ</div><div class="arrow__point " style="background-color:#EB8755;color:black"></div></div><div class="arrow__wrapper "><div class="arrow__rectangle  " style="background-color:#EB8755;color:black">OSA 2 YLEISTÄ</div><div class="arrow__point " style="background-color:#EB8755;color:black"></div></div><div class="arrow__wrapper "><div class="arrow__rectangle  " style="background-color:black;color:white">REACT</div><div class="arrow__point " style="background-color:black;color:white"></div></div></div></div></div></div><div class="course"><div class="container"><div class="col-7 course-content push-right-3" style="border-color:#EB8755"><p class="col-1 letter" style="border-color:#EB8755">b</p><h1 class="sub-header ">React</h1></div></div><div class="container"><div class="scroll-navigation col-3 element--flex element--column"></div><div class="course-content col-7">
<h2>Taulukkojen käyttö Javascriptissä</h2>
<p>Tästä osasta lähtien käytämme runsaasti Javascriptin <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">taulukkojen</a> funktionaalisia käsittelymetodeja, kuten <em>find</em>, <em>filter</em> ja <em>map</em>. Periaate niissä on täysin sama kuin Java 8:sta tutuissa streameissa, joita on käytetty jo runsaan vuoden ajan laitoksen Ohjelmoinnin perusteissa ja jatkokurssilla.</p>
<p>Jos taulukon funktionaalinen käsittely tuntuu vielä vieraalta, kannattaa katsoa Youtubessa olevasta videosarjasta <em>Functional Programming in JavaScript</em> ainakin kolme ensimmäistä osaa</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=BMUiFMZr7vk&amp;list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84">Higher-order functions</a></li>
<li><a href="https://www.youtube.com/watch?v=bCqtb-Z5YGQ&amp;list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84&amp;index=2">Map</a></li>
<li><a href="https://www.youtube.com/watch?v=Wl98eZpkp-c&amp;t=31s">Reduce basics</a></li>
</ul>
<h2>Kokoelmien renderöiminen</h2>
<p>Tehdään nyt Reactilla <a href="/osa1">ensimmäisen osan</a> alussa käytettyä esimerkkisovelluksen <a href="https://fullstack-exampleapp.herokuapp.com/spa">Single page app -versiota</a> vastaavan sovelluksen &#x27;frontend&#x27; eli selainpuolen sovelluslogiikka.</p>
<p>Aloitetaan seuraavasta:</p>
<pre><code class="language-react">import React from &#x27;react&#x27;
import ReactDOM from &#x27;react-dom&#x27;

const notes = [
  {
    id: 1,
    content: &#x27;HTML on helppoa&#x27;,
    date: &#x27;2017-12-10T17:30:31.098Z&#x27;,
    important: true
  },
  {
    id: 2,
    content: &#x27;Selain pystyy suorittamaan vain javascriptiä&#x27;,
    date: &#x27;2017-12-10T18:39:34.091Z&#x27;,
    important: false
  },
  {
    id: 3,
    content: &#x27;HTTP-protokollan tärkeimmät metodit ovat GET ja POST&#x27;,
    date: &#x27;2017-12-10T19:20:14.298Z&#x27;,
    important: true
  }
]

const App = (props) =&gt; {
  const { notes } = props;

  return (
    &lt;div&gt;
      &lt;h1&gt;Muistiinpanot&lt;/h1&gt;
      &lt;ul&gt;
        &lt;li&gt;{notes[0].content}&lt;/li&gt;
        &lt;li&gt;{notes[1].content}&lt;/li&gt;
        &lt;li&gt;{notes[2].content}&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  )
}

ReactDOM.render(
  &lt;App notes={notes} /&gt;,
  document.getElementById(&#x27;root&#x27;)
)
</code></pre>
<p>Jokaiseen muistiinpanoon on merkitty tekstuaalisen sisällön ja aikaleiman lisäksi myös <em>boolean</em>-arvo, joka kertoo onko muistiinpano luokiteltu tärkeäksi, sekä yksikäsitteinen tunniste <em>id</em>.</p>
<p>Koodin toiminta perustuu siihen, että taulukossa on tasan kolme muistiinpanoa, yksittäiset muistiinpanot renderöidään &#x27;kovakoodatusti&#x27; viittaamalla suoraan taulukossa oleviin olioihin:</p>
<pre><code class="language-html">&lt;li&gt;{note[1].content}&lt;/li&gt;
</code></pre>
<p>Tämä ei tietenkään ole järkevää. Ratkaisu voidaan yleistää generoimalla taulukon perusteella joukko React-elementtejä käyttäen <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">map</a>-funktiota:</p>
<pre><code class="language-bash">notes.map(note =&gt; &lt;li&gt;{note.content}&lt;/li&gt;)
</code></pre>
<p>nyt tuloksena on taulukko, jonka sisältö on joukko <em>li</em>-elementtejä</p>
<pre><code class="language-js">[
  &#x27;&lt;li&gt;HTML on helppoa&lt;/li&gt;&#x27;,
  &#x27;&lt;li&gt;Selain pystyy suorittamaan vain javascriptiä&lt;/li&gt;&#x27;,
  &#x27;&lt;li&gt;HTTP-protokollan tärkeimmät metodit ovat GET ja POST&lt;/li&gt;&#x27;,
];
</code></pre>
<p>jotka voidaan sijoittaa <em>ul</em>-tagien sisälle:</p>
<pre><code class="language-react">const App = (props) =&gt; {
  const { notes } = props;

  return (
    &lt;div&gt;
      &lt;h1&gt;Muistiinpanot&lt;/h1&gt;
      &lt;ul&gt;
        {notes.map(note =&gt; &lt;li&gt;{note.content}&lt;/li&gt;)}
      &lt;/ul&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>Koska li-tagit generoiva koodi on Javascriptia, tulee se sijoittaa JSX-templatessa aaltosulkujen sisälle kaiken muun Javascript-koodin tapaan.</p>
<p>Usein vastaavissa tilanteissa dynaamisesti generoitava sisältö eristetään omaan metodiin, jota JSX-template kutsuu:</p>
<pre><code class="language-react">const App = (props) =&gt; {
  const { notes } = props;
  const rivit = () =&gt; notes.map(note =&gt; &lt;li&gt;{note.content}&lt;/li&gt;)

  return (
    &lt;div&gt;
      &lt;h1&gt;Muistiinpanot&lt;/h1&gt;
      &lt;ul&gt;
        {rivit()}
      &lt;/ul&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>Vaikka sovellus näyttää toimivan, tulee konsoliin ikävä varoitus</p>
<picture><img style="border-color:#EB8755" alt="asd" src="/static/3f32af5a03d1fea93cfc8faa68fbcee5/14be6/1.png"/></picture>
<p>Kuten virheilmoituksen linkittämä <a href="https://reactjs.org/docs/lists-and-keys.html#keys">sivu</a> kertoo, tulee taulukossa olevilla, eli käytännössä <em>map</em>-metodilla muodostetuilla elementeillä olla uniikki avain, eli kenttä nimeltään <em>key</em>.</p>
<p>Lisätään avaimet:</p>
<pre><code class="language-react">const App = (props) =&gt; {
  const { notes } = props;
  const rivit = () =&gt; notes.map(note =&gt; &lt;li key={note.id}&gt;{note.content}&lt;/li&gt;)

  return (
    &lt;div&gt;
      &lt;h1&gt;Muistiinpanot&lt;/h1&gt;
      &lt;ul&gt;
        {rivit()}
      &lt;/ul&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>Virheilmoitus katoaa.</p>
<p>React käyttää taulukossa olevien elementtien key-kenttiä päätellessään miten sen tulee päivittää komponentin generoimaa näkymää silloin kun komponentti uudelleenrenderöidään. Lisää aiheesta <a href="https://reactjs.org/docs/reconciliation.html#recursing-on-children">täällä</a>.</p>
<h3>Map</h3>
<p>Taulukoiden metodin <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">map</a> toiminnan sisäistäminen on jatkon kannalta äärimmäisen tärkeää.</p>
<p>Sovellus siis sisältää taulukon <em>notes</em></p>
<pre><code class="language-js">const notes = [
  {
    id: 1,
    content: &#x27;HTML on helppoa&#x27;,
    date: &#x27;2017-12-10T17:30:31.098Z&#x27;,
    important: true,
  },
  {
    id: 2,
    content: &#x27;Selain pystyy suorittamaan vain javascriptiä&#x27;,
    date: &#x27;2017-12-10T18:39:34.091Z&#x27;,
    important: false,
  },
  {
    id: 3,
    content: &#x27;HTTP-protokollan tärkeimmät metodit ovat GET ja POST&#x27;,
    date: &#x27;2017-12-10T19:20:14.298Z&#x27;,
    important: true,
  },
];
</code></pre>
<p>Pysähdytään hetkeksi tarkastelemaan miten <em>map</em> toimii.</p>
<p>Jos esim. tiedoston loppuun lisätään seuraava koodi</p>
<pre><code class="language-js">const result = notes.map(note =&gt; note.id);
console.log(result);
</code></pre>
<p>tulostuu konsoliin <em>[1, 2, 3]</em> eli <em>map</em> muodostaa uuden taulukon, jonka jokainen alkio on saatu alkuperäisen taulukon <em>notes</em> alkioista <em>mappaamalla</em> komennon parametrina olevan funktion avulla.</p>
<p>Funktio on</p>
<pre><code class="language-js">note =&gt; note.id;
</code></pre>
<p>eli kompaktissa muodossa kirjoitettu nuolifunktio, joka on täydelliseltä kirjoitustavaltaan seuraava</p>
<pre><code class="language-js">note =&gt; {
  return note.id;
};
</code></pre>
<p>eli funktio saa parametrikseen muistiinpano-olion ja <em>palauttaa</em> sen kentän <em>id</em> arvon.</p>
<p>Muuttamalla komento muotoon</p>
<pre><code class="language-js">const result = notes.map(note =&gt; note.content);
</code></pre>
<p>tuloksena on taulukko, joka koostuu muistiinpanojen sisällöistä.</p>
<p>Tämä on jo lähellä käyttämäämme React-koodia:</p>
<pre><code class="language-bash">notes.map(note =&gt; &lt;li key={note.id}&gt;{note.content}&lt;/li&gt;)
</code></pre>
<p>joka muodostaa jokaista muistiinpano-olioa vastaavan <em>li</em>-tagin, jonka sisään tulee muistiinpanon sisältö.</p>
<p>Koska metodin <em>map</em> parametrina olevan funktion</p>
<pre><code class="language-bash">note =&gt; &lt;li key={note.id}&gt;{note.content}&lt;/li&gt;
</code></pre>
<p>käyttötarkoitus on näkymäelementtien muodostaminen, tulee muuttujan arvo renderöidä aaltosulkeiden sisällä. Kokeile mitä koodi tekee, jos poistat aaltosulkeet.</p>
<p>Aaltosulkeiden käyttö tulee varmaan aiheuttamaan alussa pientä päänvaivaa, mutta totut niihin pian. Reactin antama visuaalinen feedback on välitön.</p>
<p>Tarkastellaan vielä erästä bugien lähdettä. Lisää koodiin seuraava</p>
<pre><code class="language-bash">const result = notes.map(note =&gt; {note.content} )
console.log(result)
</code></pre>
<p>Tulostuu</p>
<pre><code class="language-bash">[undefined, undefined, undefined]
</code></pre>
<p>Missä on vika? Koodihan on ihan sama kun äsken toiminut koodi. Paitsi ei ihan. Metodin <em>map</em> parametrina on nyt seuraava funktio</p>
<pre><code class="language-js">note =&gt; {
  note.content;
};
</code></pre>
<p>Koska funktio koostuu nyt <em>koodilohkosta</em> on funktion paluuarvo määrittelemätön eli <em>undefined</em>. Nuolifunktiot siis palauttavat ainoan komentonsa arvon, ainoastaan jos nuolifunktio on määritelty kompaktissa muodossaan, ilman koodilohkoa:</p>
<pre><code class="language-js">note =&gt; note.content;
</code></pre>
<p>huomaa, että &#x27;oneliner&#x27;-nuolifunktioissa kaikkea ei tarvitse eikä aina kannatakaan kirjoittaa samalle riville.</p>
<p>Parempi muotoilu ohjelmamme muistiinpanorivit tuottavalle apufunktiolle saattaakin olla seuraava useille riveille jaoteltu versio:</p>
<pre><code class="language-bash">const rivit = () =&gt; notes.map(note =&gt;
  &lt;li key={note.id}&gt;
    {note.content}
  &lt;/li&gt;
)
</code></pre>
<p>Kyse on kuitenkin edelleen yhden komennon sisältävästä nuolifunktiosta, komento vain sattuu olemaan hieman monimutkaisempi.</p>
<h3>Antipattern: taulukon indeksit avaimina</h3>
<p>Olisimme saaneet konsolissa olevan varoituksen katoamaan myös käyttämällä avaimina taulukon indeksejä. Indeksit selviävät käyttämällä map-metodissa myös toista parametria:</p>
<pre><code class="language-js">notes.map((note, i) =&gt; ...)
</code></pre>
<p>näin kutsuttaessa <em>i</em> saa arvokseen sen paikan indeksin taulukossa, missä <em>note</em> sijaitsee.</p>
<p>Eli virheetön tapa määritellä rivien generointi on</p>
<pre><code class="language-bash">const rivit = () =&gt; notes.map((note, i) =&gt; &lt;li key={i}&gt;{note.content}&lt;/li&gt;)
</code></pre>
<p>Tämä <strong>ei kuitenkaan ole suositeltavaa</strong> ja voi näennäisestä toimimisestaan aiheuttaa joissakin tilanteissa pahoja ongelmia. Lue lisää esim. <a href="https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318">täältä</a>.</p>
<h3>Refaktorointia - moduulit</h3>
<p>Siistitään koodia hiukan. Koska olemme kiinnostuneita ainoastaan propsien kentästä <em>notes</em>, otetaan se vastaan suoraan <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">destrukturointia</a> hyödyntäen:</p>
<pre><code class="language-react">const App = ({ notes }) =&gt; {
  // ...

  return (
    &lt;div&gt;
      &lt;h1&gt;Muistiinpanot&lt;/h1&gt;
      &lt;ul&gt;
        {rivit()}
      &lt;/ul&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>Erotetaan yksittäisen muistiinpanon esittäminen oman komponenttinsa <em>Note</em> vastuulle:</p>
<pre><code class="language-react">const Note = ({ note }) =&gt; {
  return (
    &lt;li&gt;{note.content}&lt;/li&gt;
  )
}

const App = ({ notes }) =&gt; {
  return (
    &lt;div&gt;
      &lt;h1&gt;Muistiinpanot&lt;/h1&gt;
      &lt;ul&gt;
        {notes.map(note=&gt;&lt;Note key={note.id} note={note}/&gt;)}
      &lt;/ul&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>Huomaa, että <em>key</em>-attribuutti täytyy nyt määritellä <em>Note</em>-komponenteille, eikä <em>li</em>-tageille kuten ennen muutosta.</p>
<p>Koko React-sovellus on mahdollista määritellä samassa tiedostossa, mutta se ei luonnollisesti ole järkevää. Usein käytäntönä on määritellä yksittäiset komponentit omassa tiedostossaan <em>ES6-moduuleina</em>.</p>
<p>Koodissamme on käytetty koko ajan moduuleja. Tiedoston ensimmäiset rivit</p>
<pre><code class="language-js">import React from &#x27;react&#x27;;
import ReactDOM from &#x27;react-dom&#x27;;
</code></pre>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import">importtaavat</a> eli ottavat käyttöönsä kaksi moduulia. Moduuli <em>react</em> sijoitetaan muuttujaan <em>React</em> ja <em>react-dom</em> muuttujaan <em>ReactDOM</em>.</p>
<p>Siirretään nyt komponentti <em>Note</em> omaan moduuliinsa.</p>
<p>Pienissä sovelluksissa komponentit sijoitetaan yleensä <em>src</em>-hakemiston alle sijoitettavaan hakemistoon <em>components</em>. Konventiona on nimetä tiedosto komponentin mukaan, eli tehdään hakemisto <em>components</em> ja sinne tiedosto <em>Note.js</em> jonka sisältö on seuraava:</p>
<pre><code class="language-react">import React from &#x27;react&#x27;

const Note = ({ note }) =&gt; {
  return (
    &lt;li&gt;{note.content}&lt;/li&gt;
  )
}

export default Note
</code></pre>
<p>Koska kyseessä on React-komponentti, tulee React importata komponentissa.</p>
<p>Moduulin viimeisenä rivinä <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export">eksportataan</a> määritelty komponentti, eli muuttuja <em>Note</em>.</p>
<p>Nyt komponenttia käyttävä tiedosto <em>index.js</em> voi <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import">importata</a> moduulin:</p>
<pre><code class="language-react">import React from &#x27;react&#x27;
import ReactDOM from &#x27;react-dom&#x27;
import Note from &#x27;./components/Note&#x27;
</code></pre>
<p>Moduulin eksporttaama komponentti on nyt käytettävissä muuttujassa <em>Note</em> täysin samalla tavalla kuin aiemmin.</p>
<p>Huomaa, että itse määriteltyä komponenttia importatessa komponentin sijainti tulee ilmaista <em>suhteessa importtaavaan tiedostoon</em>:</p>
<pre><code class="language-react">&#x27;./components/Note&#x27;
</code></pre>
<p>Piste alussa viittaa nykyiseen hakemistoon, eli kyseessä on nykyisen hakemiston alihakemisto <em>components</em> ja sen sisällä tiedosto <em>Note.js</em>. Tiedoston päätteen voi jättää pois.</p>
<p>Koska myös <em>App</em> on komponentti, eristetään sekin omaan moduuliinsa. Koska kyseessä on sovelluksen juurikomponentti, sijoitetaan se suoraan hakemistoon <em>src</em>. Tiedoston sisältö on seuraava:</p>
<pre><code class="language-react">import React from &#x27;react&#x27;
import Note from &#x27;./components/Note&#x27;

const App = ({ notes }) =&gt; {
  return (
    &lt;div&gt;
      &lt;h1&gt;Muistiinpanot&lt;/h1&gt;
      &lt;ul&gt;
        {notes.map(note =&gt; &lt;Note key={note.id} note={note} /&gt;)}
      &lt;/ul&gt;
    &lt;/div&gt;
  )
}

export default App
</code></pre>
<p>Tiedoston <em>index.js</em> sisällöksi jää:</p>
<pre><code class="language-react">import React from &#x27;react&#x27;
import ReactDOM from &#x27;react-dom&#x27;
import App from &#x27;./App&#x27;

const notes = [
  ...
]

ReactDOM.render(
  &lt;App notes={notes} /&gt;,
  document.getElementById(&#x27;root&#x27;)
)
</code></pre>
<p>Moduuleilla on paljon muutakin käyttöä kuin mahdollistaa komponenttien määritteleminen omissa tiedostoissaan, palaamme moduuleihin tarkemmin myöhemmin kurssilla.</p>
<p>Sovelluksen tämänhetkinen koodi on kokonaisuudessaan <a href="https://github.com/FullStack-HY/part2-notes/tree/part2-1">githubissa</a></p>
<p>Huomaa, että repositorion master-haarassa on myöhemmän vaiheen koodi, tämän hetken koodi on tagissa <a href="https://github.com/FullStack-HY/part2-notes/tree/part2-1">part2-1</a>:</p>
<picture><img style="border-color:#EB8755" alt="asd" src="/static/923772eecec018fc9fa017a858fd8e35/14be6/1b.png"/></picture>
<p>Jos kloonaat projektin itsellesi, suorita komento <em>npm install</em> ennen käynnistämistä eli komentoa <em>npm start</em>.</p>
<h3>Tehtäviä kokoelmien renderöinnistä</h3>
</div></div>
<div class="banner spacing spacing--after" style="background-color:#EB8755"><div class="container"><div class="course-content col-7 push-right-3">
<h3>Tehtävät 2.1</h3>
<h4>kurssien sisältö</h4>
<p>Viimeistellään nyt tehtävien 1.1-1.5 kurssin sisältöjä renderöivän ohjelman koodi. Voit ottaa tarvittaessa pohjaksi mallivastauksen koodin.</p>
<p>Muutetaan komponentti <em>App</em> seuraavasti:</p>
<pre><code class="language-react">const App = () =&gt; {
  const kurssi = {
    nimi: &#x27;Half Stack -sovelluskehitys&#x27;,
    osat: [
      {
        nimi: &#x27;Reactin perusteet&#x27;,
        tehtavia: 10,
        id: 1
      },
      {
        nimi: &#x27;Tiedonvälitys propseilla&#x27;,
        tehtavia: 7,
        id: 2
      },
      {
        nimi: &#x27;Komponenttien tila&#x27;,
        tehtavia: 14,
        id: 3
      }
    ]
  }

  return (
    &lt;div&gt;
      &lt;Kurssi kurssi={kurssi} /&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>Määrittele sovellukseen yksittäisen kurssin muotoilusta huolehtiva komponentti <em>Kurssi</em>.</p>
<p>Sovelluksen komponenttirakenne voi olla esim. seuraava:</p>
<pre>

App
  Kurssi
    Otsikko
    Sisalto
      Osa
      Osa
      ...
</pre>
<p>ja renderöityvä sivu voi näyttää esim. seuraavalta:</p>
<picture><img style="border-color:#EB8755" alt="asd" src="/static/649b77631e24c268ac9aa2c363a1c666/14be6/8.png"/></picture>
<p>Tässä vaiheessa siis tehtävien yhteenlaskettua lukumäärää ei vielä tarvita.</p>
<p>Sovelluksen täytyy luonnollisesti toimia <em>riippumatta kurssissa olevien osien määrästä</em>, eli varmista että sovellus toimii jos lisäät tai poistat kurssin osia.</p>
<p>Varmista, että konsolissa ei näy mitään virheilmoituksia!</p>
<h3>Tehtävät 2.2</h3>
<h4>tehtävien määrä</h4>
<p>Ilmoita myös kurssin yhteenlaskettu tehtävien lukumäärä:</p>
<picture><img style="border-color:#EB8755" alt="asd" src="/static/2bcadc83ab65d725be7cb32629210702/14be6/9.png"/></picture>
<h3>Tehtävät 2.3*</h3>
<h4>reduce</h4>
<p>Jos et jo niin tehnyt, laske koodissasi tehtävien määrä taulukon metodilla <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">reduce</a>.</p>
<h3>Tehtävät 2.4</h3>
<h4>monta kurssia</h4>
<p>Laajennetaan sovellusta siten, että kursseja voi olla <em>mielivaltainen määrä</em>:</p>
<pre><code class="language-react">const App = () =&gt; {
  const kurssit = [
    {
      nimi: &#x27;Half Stack -sovelluskehitys&#x27;,
      id: 1,
      osat: [
        {
          nimi: &#x27;Reactin perusteet&#x27;,
          tehtavia: 10,
          id: 1
        },
        {
          nimi: &#x27;Tiedonvälitys propseilla&#x27;,
          tehtavia: 7,
          id: 2
        },
        {
          nimi: &#x27;Komponenttien tila&#x27;,
          tehtavia: 14,
          id: 3
        }
      ]
    },
    {
      nimi: &#x27;Node.js&#x27;,
      id: 2,
      osat: [
        {
          nimi: &#x27;Routing&#x27;,
          tehtavia: 3,
          id: 1
        },
        {
          nimi: &#x27;Middlewaret&#x27;,
          tehtavia: 7,
          id: 2
        }
      ]
    }
  ]

  return (
    &lt;div&gt;
      // ...
    &lt;/div&gt;
  )
}
</code></pre>
<p>Sovelluksen ulkoasu voi olla esim seuraava:</p>
<picture><img style="border-color:#EB8755" alt="asd" src="/static/5594d574622b8b8c7373f2cbc4af74a0/14be6/10.png"/></picture>
<h3>Tehtävät 2.5</h3>
<h4>erillinen moduuli</h4>
<p>Määrittele komponentti <em>Kurssi</em> omana moduulinaan, jonka komponentti <em>App</em> importtaa. Voit sisällyttää kaikki kurssin alikomponentit samaan moduuliin.</p>
</div></div></div>
<div class="container"><div class="scroll-navigation col-3 element--flex element--column"></div><div class="course-content col-7">
<h2>Lomakkeet</h2>
<p>Jatketaan sovelluksen laajentamista siten, että se mahdollistaa uusien muistiinpanojen lisäämisen.</p>
<p>Jotta saisimme sivun päivittymään uusien muistiinpanojen lisäyksen yhteydessä, on parasta sijoittaa muistiinpanot komponentin <em>App</em> tilaan. Funktionaalisilla komponenteilla ei ole tilaa, joten muutetaan <em>App</em> luokkaan perustuvaksi komponentiksi:</p>
<pre><code class="language-react">class App extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      notes: props.notes
    }
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Muistiinpanot&lt;/h1&gt;
        &lt;ul&gt;
          {this.state.notes.map(note =&gt; &lt;Note key={note.id} note={note} /&gt;)}
        &lt;/ul&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>Konstruktori asettaa nyt propseina saatavan <em>notes</em>-taulukon tilaan avaimen <em>notes</em> arvoksi:</p>
<pre><code class="language-js">constructor(props) {
  super(props)
  this.state = {
    notes: props.notes
  }
}
</code></pre>
<p>tila siis näyttää komponentin alustuksen jälkeen seuraavalta:</p>
<pre><code class="language-js">this.state = {
  notes: [
    {
      id: 1,
      content: &#x27;HTML on helppoa&#x27;,
      date: &#x27;2017-12-10T17:30:31.098Z&#x27;,
      important: true,
    },
    //...
  ],
};
</code></pre>
<blockquote>
<p><strong>HUOM</strong> komponenttien tilan alustaminen propseina välitettyjen arvojen perusteella ei välttämättä ole hyvä tapa, se on monien mukaan jopa <a href="https://vasanthk.gitbooks.io/react-bits/anti-patterns/01.props-in-initial-state.html">antipattern</a>. Jos kuitenkin tutkitaan vähän pintaa syvemmälle, kyseessä on ongelma lähinnä silloin <a href="https://medium.com/@justintulk/react-anti-patterns-props-in-initial-state-28687846cc2e">jos propsien arvo voi muuttua</a>. Näin ei ohjelmassamme ole, eli tilan alustaminen propsien perusteella on hyväksyttävää.</p>
</blockquote>
<p>Lisätään sitten lomake uuden muistiinpanon lisäämistä varten:</p>
<pre><code class="language-react">class App extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      notes: props.notes
    }
  }

  addNote = (event) =&gt; {
    event.preventDefault()
    console.log(&#x27;nappia painettu&#x27;)
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Muistiinpanot&lt;/h1&gt;
        &lt;ul&gt;
          {this.state.notes.map(note =&gt; &lt;Note key={note.id} note={note} /&gt;)}
        &lt;/ul&gt;
        &lt;form onSubmit={this.addNote}&gt;
          &lt;input/&gt;
          &lt;button type=&quot;submit&quot;&gt;tallenna&lt;/button&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>Lomakkeelle on lisätty myös tapahtumankäsittelijäksi metodi <em>addNote</em> reagoimaan sen &quot;lähettämiseen&quot;, eli napin painamiseen.</p>
<p>Tapahtumankäsittelijä on <a href="/osa1#tapahtumank%C3%A4sittely">osasta 1</a> tuttuun tapaan määritelty seuraavasti:</p>
<pre><code class="language-js">addNote = event =&gt; {
  event.preventDefault();
  console.log(&#x27;nappia painettu&#x27;);
  console.log(event.target);
};
</code></pre>
<p>Parametrin <em>event</em> arvona on metodin kutsun aiheuttama <a href="https://reactjs.org/docs/handling-events.html">tapahtuma</a>.</p>
<p>Tapahtumankäsittelijä kutsuu heti tapahtuman metodia <code>event.preventDefault()</code> jolla se estää lomakkeen lähetyksen oletusarvoisen toiminnan, joka aiheuttaisi mm. sivun uudelleenlatautumisen.</p>
<p>Tapahtuman kohde, eli <em>event.target</em> on tulostettu konsoliin</p>
<picture><img style="border-color:#EB8755" alt="asd" src="/static/402afeb2ecdcbfb536289f933caa11aa/14be6/2.png"/></picture>
<p>Kohteena on siis komponentin määrittelemä lomake.</p>
<p>Miten pääsemme käsiksi lomakkeen <em>input</em>-komponenttiin syötettyyn dataan?</p>
<p>Tapoja on useampia, tutustumme ensin ns. <a href="https://reactjs.org/docs/forms.html#controlled-components">kontrolloituina komponentteina</a> toteutettuihin lomakkeisiin.</p>
<p>Lisätään komponentin <em>App</em> tilaan kenttä <em>newNote</em> lomakkeen syötettä varten:</p>
<pre><code class="language-js">class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      notes: props.notes,
      newNote: &#x27;uusi muistiinpano...&#x27;,
    };
  }
  // ...
}
</code></pre>
<p>Määritellään tilaan lisätty kenttä <em>input</em>-komponentin attribuutin <em>value</em> arvoksi:</p>
<pre><code class="language-html">&lt;form onSubmit=&quot;{this.addNote}&quot;&gt;
  &lt;input value=&quot;{this.state.newNote}&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;tallenna&lt;/button&gt;
&lt;/form&gt;
</code></pre>
<p>Tilaan määritelty &quot;placeholder&quot;-teksti <em>uusi muistiinpano...</em> ilmestyy syötekomponenttiin, tekstiä ei kuitenkaan voi muuttaa. Konsoliin tuleekin ikävä varoitus joka kertoo mistä on kyse</p>
<picture><img style="border-color:#EB8755" alt="asd" src="/static/9c8e6d08ec7b853179f16d7a8ff4604e/14be6/4.png"/></picture>
<p>Koska määrittelimme syötekomponentille <em>value</em>-attribuutiksi komponentin <em>App</em> tilassa olevan kentän, alkaa <em>App</em> <a href="https://reactjs.org/docs/forms.html#controlled-components">kontrolloimaan</a> syötekomponentin toimintaa.</p>
<p>Jotta kontrolloidun syötekomponentin editoiminen olisi mahdollista, täytyy sille rekisteröidä <em>tapahtumankäsittelijä</em>, joka synkronoi syötekenttään tehdyt muutokset komponentin <em>App</em> tilaan:</p>
<pre><code class="language-react">class App extends React.Component {
  // ...

  handleNoteChange = (event) =&gt; {
    console.log(event.target.value)
    this.setState({ newNote: event.target.value })
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Muistiinpanot&lt;/h1&gt;
        &lt;ul&gt;
          {this.state.notes.map(note =&gt; &lt;Note key={note.id} note={note} /&gt;)}
        &lt;/ul&gt;
        &lt;form onSubmit={this.addNote}&gt;
          &lt;input
            value={this.state.newNote}
            onChange={this.handleNoteChange}
          /&gt;
          &lt;button type=&quot;submit&quot;&gt;tallenna&lt;/button&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>Lomakkeen <em>input</em>-komponentille on nyt rekisteröity tapahtumankäsittelijä tilanteeseen <em>onChange</em>:</p>
<pre><code class="language-html">&lt;input value=&quot;{this.state.newNote}&quot; onChange=&quot;{this.handleNoteChange}&quot; /&gt;
</code></pre>
<p>Tapahtumankäsittelijää kutsutaan <em>aina kun syötekomponentissa tapahtuu jotain</em>. Tapahtumankäsittelijämetodi saa parametriksi tapahtumaolion <em>event</em></p>
<pre><code class="language-js">handleNoteChange = event =&gt; {
  console.log(event.target.value);
  this.setState({ newNote: event.target.value });
};
</code></pre>
<p>Tapahtumaolion kenttä <em>target</em> vastaa nyt kontrolloitua <em>input</em>-kenttää ja <em>event.target.value</em> viittaa inputin syötekentän arvoon.</p>
<p>Huomaa, että toisin kuin tapahtuman <em>onSubmit</em> käsittelijässä, nyt oletusarvoisen toiminnan estävää metodikutusua <em>event.preventDefault()</em> ei tarvita sillä syötekentän muutoksella ei ole oletusarvoista toimintaa toisin kuin lomakkeen lähettämisellä.</p>
<p>Voit seurata konsolista miten tapahtumankäsittelijää kutsutaan:</p>
<picture><img style="border-color:#EB8755" alt="asd" src="/static/b5f424c1a27a758a88c8bba86dc78aaf/14be6/5.png"/></picture>
<p>Muistithan jo asentaa <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi">React devtoolsin</a>? Devtoolsista näet, miten tila muuttuu syötekenttään kirjoitettaessa:</p>
<picture><img style="border-color:#EB8755" alt="asd" src="/static/de515c2b2e73fed381f6b4182773ac99/14be6/5a.png"/></picture>
<p>Nyt komponentin <em>App</em> tilan kenttä <em>newNote</em> heijastaa koko ajan syötekentän arvoa, joten voimme viimeistellä uuden muistiinpanon lisäämisestä huolehtivan metodin <em>addNote</em>:</p>
<pre><code class="language-js">addNote = event =&gt; {
  event.preventDefault();
  const noteObject = {
    content: this.state.newNote,
    date: new Date().toISOString(),
    important: Math.random() &gt; 0.5,
    id: this.state.notes.length + 1,
  };

  const notes = this.state.notes.concat(noteObject);

  this.setState({
    notes: notes,
    newNote: &#x27;&#x27;,
  });
};
</code></pre>
<p>Ensin luodaan uutta muistiinpanoa vastaava olio <em>noteObject</em>, jonka sisältökentän arvo saadaan komponentin tilasta <em>this.state.newNote</em>. Yksikäsitteinen tunnus eli <em>id</em> generoidaan kaikkien muistiinpanojen lukumäärän perusteella. Koska muistiinpanoja ei poisteta, menetelmä toimii sovelluksessamme. Komennon <code>Math.random()</code> avulla muistiinpanosta tulee 50% todennäköisyydellä tärkeä.</p>
<p>Uusi muistiinpano lisätään vanhojen joukkoon oikeaoppisesti käyttämällä <a href="/osa1#taulukon-k%C3%A4sittely%C3%A4">osasta 1</a> tuttua taulukon metodia <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat">concat</a>:</p>
<pre><code class="language-js">const notes = this.state.notes.concat(noteObject);
</code></pre>
<p>Metodi ei muuta alkuperäistä taulukkoa <em>this.state.notes</em> vaan luo uuden taulukon, joka sisältää myös lisättävän alkion. Tämä on tärkeää, sillä Reactin tilaa <a href="https://reactjs.org/docs/state-and-lifecycle.html#using-state-correctly">ei saa muuttaa suoraan</a>!</p>
<p>Lopussa komponentin tila päivitetään uusilla muistiinpanoilla ja tyhjentämällä syötekomponentin arvoa kontrolloiva kenttä:</p>
<pre><code class="language-js">this.setState({
  notes: notes,
  newNote: &#x27;&#x27;,
});
</code></pre>
<h3>Kehittyneempi tapa olioliteraalien kirjoittamiseen</h3>
<p>Voimme muuttaa tilan päivittämän koodin</p>
<pre><code class="language-js">this.setState({
  notes: notes,
  newNote: &#x27;&#x27;,
});
</code></pre>
<p>muotoon</p>
<pre><code class="language-js">this.setState({
  notes,
  newNote: &#x27;&#x27;,
});
</code></pre>
<p>Tämä johtuu siitä, että ES6:n myötä (ks. kohta <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer">property definitions</a>) Javascriptiin on tullut uusi ominaisuus, joka mahdollistaa hieman tiiviimmän tavan muuttujien avulla tapahtuvaan olioiden määrittelyyn.</p>
<p>Tarkastellaan tilannetta, jossa meillä on muuttujissa arvoja</p>
<pre><code class="language-js">const name = &#x27;Leevi&#x27;;
const age = 0;
</code></pre>
<p>ja haluamme määritellä näiden perusteella olion, jolla on kentät <em>name</em> ja <em>age</em>.</p>
<p>Vanhassa Javascriptissä olio täytyi määritellä seuraavaan tyyliin</p>
<pre><code class="language-js">const person = {
  name: name,
  age: age,
};
</code></pre>
<p>koska muuttujien ja luotavan olion kenttien nimi nyt on sama, riittää ES6:ssa kirjoittaa:</p>
<pre><code class="language-js">const person = { name, age };
</code></pre>
<p>lopputulos molemmilla tavoilla luotuun olioon on täsmälleen sama.</p>
<p>Sovelluksen tämän hetkinen koodi on kokonaisuudessaan <a href="https://github.com/FullStack-HY/part2-notes/tree/part2-2">githubissa</a>, tagissa <em>part2-2</em>.</p>
<h2>Näytettävien elementtien filtteröinti</h2>
<p>Tehdään sovellukseen toiminto, joka mahdollistaa ainoastaan tärkeiden muistiinpanojen näyttämisen.</p>
<p>Lisätään komponentin <em>App</em> tilaan tieto siitä näytetäänkö muistiinpanoista kaikki vai ainoastaan tärkeät:</p>
<pre><code class="language-react">class App extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      notes: props.notes ,
      newNote: &#x27;&#x27;,
      showAll: true
    }
  }
  // ...
}
</code></pre>
<p>Muutetaan metodia <em>render</em> siten, että se tallettaa muuttujaan <em>notesToShow</em> näytettävien muistiinpanojen listan riippuen siitä tuleeko näyttää kaikki vai vain tärkeät:</p>
<pre><code class="language-react">render() {
  const notesToShow =
    this.state.showAll ?
      this.state.notes :
      this.state.notes.filter(note =&gt; note.important === true)

  return (
    &lt;div&gt;
      &lt;h1&gt;Muistiinpanot&lt;/h1&gt;
      &lt;ul&gt;
        {notesToShow.map(note =&gt; &lt;Note key={note.id} note={note} /&gt;)}
      &lt;/ul&gt;
      &lt;form onSubmit={this.addNote}&gt;
        &lt;input
          value={this.state.newNote}
          onChange={this.handleNoteChange}
        /&gt;
        &lt;button type=&quot;submit&quot;&gt;tallenna&lt;/button&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>Muuttujan <em>notesToShow</em> määrittely on melko kompakti</p>
<pre><code class="language-js">const notesToShow = this.state.showAll
  ? this.state.notes
  : this.state.notes.filter(note =&gt; note.important === true);
</code></pre>
<p>Käytössä on monissa muissakin kielissä oleva <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator">ehdollinen</a> operaatio.</p>
<p>Operaatio toimii seuraavasti. Jos meillä on esim:</p>
<pre><code class="language-js">const tulos = ehto ? val1 : val2;
</code></pre>
<p>muuttujan <em>tulos</em> arvoksi asetetaan <em>val1</em>:n arvo jos <em>ehto</em> on tosi. Jos <em>ehto</em> ei ole tosi, muuttujan <em>tulos</em> arvoksi tulee <em>val2</em>:n arvo.</p>
<p>Jos ehto <em>this.state.showAll</em> on epätosi, muuttuja <em>notesToShow</em> saa arvokseen vaan ne muistiinpanot, joiden <em>important</em>-kentän arvo on tosi. Filtteröinti tapahtuu taulukon metodilla <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">filter</a>:</p>
<pre><code class="language-js">this.state.notes.filter(note =&gt; note.important === true);
</code></pre>
<p>vertailu-operaatio on oikeastaan turha koska <em>note.important</em> on arvoltaan joko <em>true</em> tai <em>false</em>, eli riittää kirjoittaa</p>
<pre><code class="language-js">this.state.notes.filter(note =&gt; note.important);
</code></pre>
<p>Tässä käytettiin kuitenkin ensin vertailuoperaattoria, mm. korostamaan erästä tärkeää seikkaa: Javascriptissa <code>arvo1 == arvo2</code> ei toimi kaikissa tilanteissa loogisesti ja onkin varmempi käyttää aina vertailuissa muotoa <code>arvo1 === arvo2</code>. Enemmän aiheesta <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness">täällä</a>.</p>
<p>Filtteröinnin toimivuutta voi jo nyt kokeilla vaihtelemalla sitä, miten tilan kentän <em>showAll</em> alkuarvo määritelään konstruktorissa.</p>
<p>Lisätään sitten toiminnallisuus, mikä mahdollistaa <em>showAll</em>:in tilan muuttamisen sovelluksesta.</p>
<p>Oleelliset muutokset ovat seuraavassa:</p>
<pre><code class="language-react">class App extends React.Component {
  // ...

  toggleVisible = () =&gt; {
    this.setState({showAll: !this.state.showAll})
  }

  render() {
    const notesToShow =
      this.state.showAll ?
        this.state.notes :
        this.state.notes.filter(note =&gt; note.important === true)

    const label = this.state.showAll ? &#x27;vain tärkeät&#x27; : &#x27;kaikki&#x27;

    return (
      &lt;div&gt;
        &lt;h1&gt;Muistiinpanot&lt;/h1&gt;

        &lt;div&gt;
          &lt;button onClick={this.toggleVisible}&gt;
            näytä {label}
          &lt;/button&gt;
        &lt;/div&gt;

        &lt;ul&gt;
          {notesToShow.map(note =&gt; &lt;Note key={note.id} note={note} /&gt;)}
        &lt;/ul&gt;
        &lt;form onSubmit={this.addNote}&gt;
          &lt;input
            value={this.state.newNote}
            onChange={this.handleNoteChange}
          /&gt;
          &lt;button type=&quot;submit&quot;&gt;tallenna&lt;/button&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>Näkyviä muistiinpanoja (kaikki vai ainoastaan tärkeät) siis kontrolloidaan napin avulla. Napin tapahtumankäsittelijä on yksinkertainen, se muuttaa <em>this.state.showAll</em>:n arvon truesta falseksi ja päinvastoin:</p>
<pre><code class="language-js">toggleVisible = () =&gt; {
  this.setState({ showAll: !this.state.showAll });
};
</code></pre>
<p>Napin teksti määritellään muuttujaan, jonka arvo määräytyy tilan perusteella:</p>
<pre><code class="language-js">const label = this.state.showAll ? &#x27;vain tärkeät&#x27; : &#x27;kaikki&#x27;;
</code></pre>
<p>Sovelluksen tämän hetkinen koodi on kokonaisuudessaan <a href="https://github.com/FullStack-HY/part2-notes/tree/part2-3">githubissa</a>, tagissa <em>part2-3</em>.</p>
</div></div>
<div class="banner spacing spacing--after" style="background-color:#EB8755"><div class="container"><div class="course-content col-7 push-right-3">
<h3>Tehtävät 2.6</h3>
<h4>puhelinluettelo osa 1</h4>
<p>Toteutetaan yksinkertainen puhelinluettelo. <strong>Aluksi luetteloon lisätään vaan nimiä.</strong></p>
<p>Voit ottaa sovelluksesi pohjaksi seuraavan:</p>
<pre><code class="language-react">import React from &#x27;react&#x27;;

class App extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      persons: [
        { name: &#x27;Arto Hellas&#x27; }
      ],
      newName: &#x27;&#x27;
    }
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h2&gt;Puhelinluettelo&lt;/h2&gt;
        &lt;form&gt;
          &lt;div&gt;
            nimi: &lt;input /&gt;
          &lt;/div&gt;
          &lt;div&gt;
            &lt;button type=&quot;submit&quot;&gt;lisää&lt;/button&gt;
          &lt;/div&gt;
        &lt;/form&gt;
        &lt;h2&gt;Numerot&lt;/h2&gt;
        ...
      &lt;/div&gt;
    )
  }
}

export default App
</code></pre>
<p>Tilassa oleva kenttä <em>newName</em> on tarkoitettu lomakkeen kentän kontrollointiin.</p>
<p>Joskus tilan muuttujia ja tarvittaessa muitakin voi olla hyödyllistä renderöidä debugatessa komponenttiin, eli voi tilapäisesti lisätä komponentin metodin <em>render</em> palauttamaan koodiin esim. seuraavan:</p>
<pre><code class="language-html">&lt;div&gt;debug: {this.state.newName}&lt;/div&gt;
</code></pre>
<p>Muista myös osan 1 luku <a href="#react-sovellusten-debuggaus">React-sovellusten debuggaus</a>, erityisesti <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi">react developer tools</a> on välillä todella kätevä komponentin tilan muutosten seuraamisessa.</p>
<p>Sovellus voi näyttää tässä vaiheessa seuraavalta:</p>
<picture><img style="border-color:#EB8755" alt="asd" src="/static/60446030ea8355a3fb52e43afb9b73b4/14be6/11.png"/></picture>
<p>Huomaa, React developer toolsin käyttö!</p>
<p><strong>Huom:</strong></p>
<ul>
<li>voit käyttää kentän <em>key</em> arvona henkilön nimeä</li>
<li>muista estää lomakkeen lähetyksen oletusarvoinen toiminta!</li>
</ul>
<h3>Tehtävät 2.7</h3>
<h4>puhelinluettelo osa 2</h4>
<p>Jos lisättävä nimi on jo sovelluksen tiedossa, estä lisäys. Taulukolla on lukuisia sopivia <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">metodeja</a> tehtävän tekemiseen.</p>
<p>Voit antaa halutessasi virheilmoituksen esim. komennolla <em>alert()</em>. Se ei kuitenkaan ole tarpeen.</p>
<h3>Tehtävät 2.8</h3>
<h4>puhlelinluettelo osa 3</h4>
<p>Lisää sovellukseen mahdollisuus antaa henkilöille puhelinnumero. Tarvitset siis lomakkeeseen myös toisen <em>input</em>-elementin (ja sille oman muutoksenkäsittelijän):</p>
<pre><code class="language-html">&lt;form&gt;
  &lt;div&gt;nimi: &lt;input /&gt;&lt;/div&gt;
  &lt;div&gt;numero: &lt;input /&gt;&lt;/div&gt;
  &lt;div&gt;&lt;button type=&quot;submit&quot;&gt;lisää&lt;/button&gt;&lt;/div&gt;
&lt;/form&gt;
</code></pre>
<p>Sovellus voi näyttää tässä vaiheessa seuraavalta. Kuvassa myös <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi">react developer tools</a>:in tarjoama näkymä komponentin <em>App</em> tilaan:</p>
<picture><img style="border-color:#EB8755" alt="asd" src="/static/dd6fe4b6d9f8013fd1244ecd77b3010d/14be6/12.png"/></picture>
<h3>Tehtävät 2.9*</h3>
<h4>puhelinluettelo osa 4</h4>
<p>Tee lomakkeeseen hakukenttä, jonka avulla näytettävien nimien listaa voidaan rajata:</p>
<picture><img style="border-color:#EB8755" alt="asd" src="/static/3257039afad6bed5eec6657bd4a3b484/14be6/12c.png"/></picture>
<p>Rajausehdon syöttämisen voi hoitaa omana lomakkeeseen kuulumattomana <em>input</em>-elementtinä. Kuvassa rajausehdosta on tehty <em>caseinsensitiivinen</em> eli ehto <em>arto</em> löytää isolla kirjaimella kirjoitetun Arton.</p>
<p><strong>Huom:</strong> Kun toteutat jotain uutta toiminnallisuutta, on usein hyötyä &#x27;kovakoodata&#x27; sovellukseen jotain sisältöä, esim.</p>
<pre><code class="language-js">constructor(props) {
  super(props)
  this.state = {
    persons: [
      { name: &#x27;Arto Hellas&#x27;, number: &#x27;040-123456&#x27; },
      { name: &#x27;Martti Tienari&#x27;, number: &#x27;040-123456&#x27; },
      { name: &#x27;Arto Järvinen&#x27;, number: &#x27;040-123456&#x27; },
      { name: &#x27;Lea Kutvonen&#x27;, number: &#x27;040-123456&#x27; }
    ],
    newName: &#x27;&#x27;,
    newNumber: &#x27;&#x27;,
    filter: &#x27;&#x27;
  }
}
</code></pre>
<p>Näin vältytään turhalta manuaaliselta työltä, missä testaaminen edellyttäisi myös testiaineiston syöttämistä käsin soveluksen lomakkeen kautta.</p>
<p>Kurssin seuraavasta osasta alkaen alamme määrittelemään sovelluksemme <em>testejä</em> jotka tietyissä tapauksissa hoitavat kovakoodatun apusyötteen roolia.</p>
<h3>Tehtävät 2.10</h3>
<h4>puhelinluettelo osa 5</h4>
<p>Jos koko sovelluksesi on tehty yhteen komponenttiin, refaktoroi sitä eriyttämällä sopivia komponentteja. Pidä kuitenkin edelleen kaikki tila juurikomponentissa.</p>
<p>Riittää että erotat sovelluksesta kaksi komponenttia. Hyviä kandidaatteja ovat esim. filtteröintilomake, yksittäisten henkilön tietojen esittäminen ja uuden henkilön lisäävä lomake.</p>
</div></div></div>
<div class="container"><div class="scroll-navigation col-3 element--flex element--column"></div><div class="course-content col-7">
<h2>Datan haku palvelimelta</h2>
<p>Olemme nyt viipyneet tovin keskittyen pelkkään &quot;frontendiin&quot;, eli selainpuolen toiminnallisuuteen. Rupeamme itse toteuttamaan &quot;backendin&quot;, eli palvelinpuolen toiminnallisuutta vasta kurssin kolmannessa osassa, mutta otamme nyt jo askeleen sinne suuntaan tutustumalla siihen miten selaimessa suoritettava koodi kommunikoi backendin kanssa.</p>
<p>Käytetään nyt palvelimena sovelluskehitykseen tarkoitettua <a href="https://github.com/typicode/json-server">JSON Serveriä</a>.</p>
<p>Tee projektin juurihakemistoon tiedosto <em>db.json</em>, jolla on seuraava sisältö:</p>
<pre><code class="language-json">{
  &quot;notes&quot;: [
    {
      &quot;id&quot;: 1,
      &quot;content&quot;: &quot;HTML on helppoa&quot;,
      &quot;date&quot;: &quot;2017-12-10T17:30:31.098Z&quot;,
      &quot;important&quot;: true
    },
    {
      &quot;id&quot;: 2,
      &quot;content&quot;: &quot;Selain pystyy suorittamaan vain javascriptiä&quot;,
      &quot;date&quot;: &quot;2017-12-10T18:39:34.091Z&quot;,
      &quot;important&quot;: false
    },
    {
      &quot;id&quot;: 3,
      &quot;content&quot;: &quot;HTTP-protokollan tärkeimmät metodit ovat GET ja POST&quot;,
      &quot;date&quot;: &quot;2017-12-10T19:20:14.298Z&quot;,
      &quot;important&quot;: true
    }
  ]
}
</code></pre>
<p>JSON server on mahdollista <a href="https://github.com/typicode/json-server#install">asentaa</a> koneelle ns. globaalisti komennolla <em>npm install -g json-server</em>. Globaali asennus edellyttää kuitenkin pääkäyttäjän oikeuksia, eli se ei ole mahdollista laitoksen koneilla tai uusilla fuksiläppäreillä.</p>
<p>Globaali asennus ei kuitenkaan ole tarpeen, voimme käynnistää <em>json-serverin</em> komennon <em>npx</em> avulla:</p>
<pre><code class="language-bash">npx json-server --port=3001 --watch db.json
</code></pre>
<p>Oletusarvoisesti <em>json-server</em> käynnistyy porttiin 3000, mutta create-react-app:illa luodut projektit varaavat portin 3000, joten joudumme nyt määrittelemään json-server:ille vaihtoehtoisen portin 3001.</p>
<p>Mennään selaimella osoitteeseen <a href="http://localhost:3001/notes">http://localhost:3001/notes</a>. Kuten huomaamme, <em>json-server</em> tarjoaa osoitteessa tiedostoon tallentamamme muistiinpanot JSON-muodossa:</p>
<picture><img style="border-color:#EB8755" alt="asd" src="/static/118d8a18ebbe17bd894c7be2f57b5bc2/14be6/6.png"/></picture>
<p>Ideana jatkossa onkin se, että muistiinpanot talletetaan palvelimelle, eli tässä vaiheessa <em>json-server</em>:ille. React-koodi lataa muistiinpanot palvelimelta ja renderöi ne ruudulle. Kun sovellukseen lisätään uusi muistiinpano, React-koodi lähettää sen myös palvelimelle, jotta uudet muistiinpanot jäävät pysyvästi &quot;muistiin&quot;.</p>
<p>json-server tallettaa kaiken datan palvelimella sijaitsevaan tiedostoon <em>db.json</em>. Todellisuudessa data tullaan tallentamaan johonkin tietokantaan. json-server on kuitenkin käyttökelpoinen apuväline, joka mahdollistaa palvelinpuolen toiminnallisuuden käyttämisen kehitysvaiheessa ilman tarvetta itse ohjelmoida mitään.</p>
<p>Tutustumme palvelinpuolen toteuttamisen periaatteisiin tarkemmin kurssin <a href="/osa3">osassa 3</a>.</p>
<h3>Selain suoritusympäristönä</h3>
<p>Ensimmäisenä tehtävänämme on siis hakea React-sovellukseen jo olemassaolevat mustiinpanot osoitteesta <a href="http://localhost:3001/notes">http://localhost:3001/notes</a>.</p>
<p>Osan 0 <a href="/osa0#selaimessa-suoritettava-sovelluslogiikka">esimerkkiprojektissa</a> nähtiin jo eräs tapa hakea Javascript-koodista palvelimella olevaa dataa. Esimerkin koodissa data haettiin <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a>- eli XHR-olion avulla muodostetulla HTTP-pyynnöllä. Kyseessä on vuonna 1999 lanseerattu tekniikka, jota kaikki web-selaimet ovat jo pitkään tukeneet.</p>
<p>Nykyään XHR:ää ei kuitenkaan kannata käyttää ja selaimet tukevatkin jo laajasti <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch">fetch</a>-metodia, joka perustuu XHR:n käyttämän tapahtumapohjaisen mallin sijaan ns. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">promiseihin</a>.</p>
<p>Muistutuksena edellisestä osasta (oikeastaan tätä tapaa pitää lähinnä <em>muistaa olla käyttämättä</em> ilman painavaa syytä), XHR:llä haettiin dataa seuraavasti</p>
<pre><code class="language-js">const xhttp = new XMLHttpRequest();

xhttp.onreadystatechange = function() {
  if (this.readyState == 4 &amp;&amp; this.status == 200) {
    const data = JSON.parse(this.responseText);
    // käsittele muuttujaan data sijoitettu kyselyn tulos
  }
};

xhttp.open(&#x27;GET&#x27;, &#x27;/data.json&#x27;, true);
xhttp.send();
</code></pre>
<p>Heti alussa HTTP-pyyntöä vastaavalle <em>xhttp</em>-oliolle rekisteröidään <em>tapahtumankäsittelijä</em>, jota Javascript runtime kutsuu kun <em>xhttp</em>-olion tila muuttuu. Jos tilanmuutos tarkoittaa että pyynnön vastaus on saapunut, käsitellään data halutulla tavalla.</p>
<p>Huomionarvoista on se, että tapahtumankäsittelijän koodi on määritelty jo ennen kun itse pyyntö lähetetään palvelimelle. Tapahtumankäsittelijäfunktio tullaan kuitenkin suorittamaan vasta jossain myöhäisemmässä vaiheessa. Koodin suoritus ei siis etene synkronisesti &quot;ylhäältä alas&quot;, vaan <em>asynkronisesti</em>, Javascript kutsuu sille rekisteröityä tapahtumankäsittelijäfunktiota jossain vaiheessa.</p>
<p>Esim. Java-ohjelmoinnista tuttu synkroninen tapa tehdä kyselyjä etenisi seuraavaan tapaan (huomaa että kyse ei ole oikeasti toimivasta Java-koodista):</p>
<pre><code class="language-java">HTTPRequest request = new HTTPRequest()

String url = &quot;https://fullstack-exampleapp.herokuapp.com/data.json&quot;;
List&lt;Muistiinpano&gt; muistiinpanot = request.get(url);

muistiinpanot.forEach(m =&gt; {
  System.out.println(m.content);
})
</code></pre>
<p>Javassa koodi etenee nyt rivi riviltä ja koodi pysähtyy odottamaan HTTP-pyynnön, eli komennon <em>request.get(...)</em> valmistumista. Komennon palauttama data, eli muistiinpanot talletetaan muuttujaan ja dataa aletaan käsittelemään halutulla tavalla.</p>
<p>Javascript-enginet eli suoritusympäristöt kuitenkin noudattavat <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop">asynkronista mallia</a>, eli periaatteena on se, että kaikki <a href="https://en.wikipedia.org/wiki/Input/output">IO-operaatiot</a> (poislukien muutama poikkeus) suoritetaan ei-blokkaavana, eli operaatioiden tulosta ei jäädä odottamaan vaan koodin suoritusta jatketaan heti eteenpäin.</p>
<p>Siinä vaiheessa kun operaatio valmistuu tai tarkemmin sanoen jonain valmistumisen jälkeisenä ajanhetkenä, kutsuu Javascript-engine operaatiolle rekisteröityjä tapahtumankäsittelijöitä.</p>
<p>Nykyisellään Javascript-moottorit ovat <em>yksisäikeisiä</em> eli ne eivät voi suorittaa rinnakkaista koodia. Tämän takia on käytännössä pakko käyttää ei-blokkaavaa mallia IO-operaatioiden suorittamiseen, sillä muuten selain &#x27;jäätyisi&#x27; siksi aikaa kun esim. palvelimelta haetaan dataa.</p>
<p>Javascript-moottoreiden yksisäikeisyydellä on myös sellainen seuraus, että jos koodin suoritus kestää erittäin pitkään, menee selain jumiin suorituksen ajaksi. Jos lisätään jonnekin kohtaa sovellustamme, esim. konstruktoriin seuraava koodi:</p>
<pre><code class="language-js">setTimeout(() =&gt; {
  console.log(&#x27;loop..&#x27;);
  let i = 0;
  while (i &lt; 50000000000) {
    i++;
  }
  console.log(&#x27;end&#x27;);
}, 5000);
</code></pre>
<p>Kaikki toimii 5 sekunnin ajan normaalisti. Kun <em>setTimeout</em>:in parametrina määritelty funktio suoritetaan, menee selaimen sivu jumiin pitkän loopin suorituksen ajaksi. Ainakaan Chromessa selaimen tabia ei pysty edes sulkemaan luupin suorituksen aikana.</p>
<p>Eli jotta selain säilyy <em>responsiivisena</em>, eli että se reagoi koko ajan riittävän nopeasti käyttäjän haluamiin toimenpiteisiin, koodin logiikan tulee olla sellainen, että yksittäinen laskenta ei saa kestää liian kauaa.</p>
<p>Aiheesta löytyy paljon lisämateriaalia internetistä, eräs varsin havainnollinen esitys aiheesta Philip Robertsin esitelmä <a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">What the heck is the event loop anyway?</a></p>
<p>Nykyään selaimissa on mahdollisuus suorittaa myös rinnakkaista koodia ns. <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">web workerien</a> avulla. Yksittäisen selainikkunan koodin ns. event loopista huolehtii kuitenkin edelleen <a href="https://medium.com/techtrument/multithreading-javascript-46156179cf9a">vain yksi säie</a>.</p>
<h2>npm</h2>
<p>Palaamme jälleen asiaan, eli datan hakemiseen palvelimelta.</p>
<p>Voisimme käyttää datan palvelimelta hakemiseen aiemmin mainittua promiseihin perustuvaa funktiota <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch">fetch</a>. Fetch on hyvä työkalu, se on standardoitu ja kaikkien modernien selaimien (poislukien IE) tukema.</p>
<p>Käytetään selaimen ja palvelimen väliseen kommunikaatioon kuitenkin <a href="https://github.com/axios/axios">axios</a>-kirjastoa, joka toimii samaan tapaan kuin fetch, mutta on hieman mukavampikäyttöinen. Hyvä syy axios:in käytölle on myös se, että pääsemme tutustumaan siihen miten ulkopuolisia kirjastoja eli <em>npm-paketteja</em> liitetään React-projektiin.</p>
<p>Nykyään lähes kaikki Javascript-projektit määritellään node &quot;pakkausmanagerin&quot; eli <a href="https://docs.npmjs.com/getting-started/what-is-npm">npm</a>:n avulla. Myös create-react-app:in avulla generoidut projektit ovat npm-muotoisia projekteja. Varma tuntomerkki siitä on projektin juuressa oleva tiedosto <em>package.json</em>:</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;osa2&quot;,
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;private&quot;: true,
  &quot;dependencies&quot;: {
    &quot;react&quot;: &quot;^16.2.0&quot;,
    &quot;react-dom&quot;: &quot;^16.2.0&quot;,
    &quot;react-scripts&quot;: &quot;1.0.17&quot;
  },
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;react-scripts start&quot;,
    &quot;build&quot;: &quot;react-scripts build&quot;,
    &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;,
    &quot;eject&quot;: &quot;react-scripts eject&quot;
  }
}
</code></pre>
<p>Tässä vaiheessa meitä kiinnostaa osa <em>dependencies</em>, joka määrittelee mitä <em>riippuvuuksia</em> eli ulkoisia kirjastoja projektilla on.</p>
<p>Haluamme nyt käyttöömme axioksen. Voisimme määritellä kirjaston suoraan tiedostoon <em>package.json</em>, mutta on parempi asentaa se komentoriviltä</p>
<pre><code class="language-bash">npm install axios --save
</code></pre>
<p><strong>Huomaa, että <em>npm</em>-komennot tulee antaa aina projektin juurihakemistossa</strong>, eli siinä minkä sisältä tiedosto <em>package.json</em> löytyy.</p>
<p>Nyt axios on mukana riippuvuuksien joukossa:</p>
<pre><code class="language-json">{
  &quot;dependencies&quot;: {
    &quot;axios&quot;: &quot;^0.17.1&quot;,
    &quot;react&quot;: &quot;^16.2.0&quot;,
    &quot;react-dom&quot;: &quot;^16.2.0&quot;,
    &quot;react-scripts&quot;: &quot;1.0.17&quot;
  }
  /*...*/
}
</code></pre>
<p>Sen lisäksi, että komento <em>npm install</em> lisäsi axiosin riippuvuuksien joukkoon, se myös <em>latasi</em> kirjaston koodin. Koodi löytyy muiden riippuvuuksien tapaan projektin juuren hakemistosta <em>node</em>modules_, mikä kuten huomata saattaa sisältääkin runsaasti kaikenlaista.</p>
<p>Tehdään toinenkin pieni lisäys. Asennetaan myös <em>json-server</em> projektin riippuvuudeksi komennolla</p>
<pre><code class="language-bash">npm install json-server --save
</code></pre>
<p>ja lisätään tiedoston <em>package.json</em> osaan <em>scripts</em> rivi</p>
<pre><code class="language-bash">&quot;server&quot;: &quot;json-server -p3001 db.json&quot;
</code></pre>
<p>eli muutetaan se muotoon</p>
<pre><code class="language-json">{
  /*...*/
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;react-scripts start&quot;,
    &quot;build&quot;: &quot;react-scripts build&quot;,
    &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;,
    &quot;eject&quot;: &quot;react-scripts eject&quot;,
    &quot;server&quot;: &quot;json-server -p3001 db.json&quot;
  }
}
</code></pre>
<p>Nyt voimme käynnistää (muista sammuttaa aiemmin käynnistämäsi!) json-serverin projektin hakemistosta mukavasti ilman tarvetta parametrien määrittelylle komennolla</p>
<pre><code class="language-bash">npm run server
</code></pre>
<p>Tutustumme npm:n tarkemmin kurssin <a href="/osa3">kolmannessa osassa</a>.</p>
<h3>Axios ja promiset</h3>
<p>Olemme nyt valmiina käyttämään axiosia. Jatkossa oletetaan että <em>json-server</em> on käynnissä portissa 3001.</p>
<p>Kirjaston voi ottaa käyttöön samaan tapaan kuin esim. React otetaan käyttöön, eli sopivalla <em>import</em>-lauseella.</p>
<p>Lisätään seuraava tiedostoon <em>index.js</em></p>
<pre><code class="language-js">import axios from &#x27;axios&#x27;;

const promise = axios.get(&#x27;http://localhost:3001/notes&#x27;);
console.log(promise);

const promise2 = axios.get(&#x27;http://localhost:3001/foobar&#x27;);
console.log(promise2);
</code></pre>
<p>Konsoliin tulostuu seuraavaa</p>
<picture><img style="border-color:#EB8755" alt="asd" src="/static/b1f90db7a9d23af450c57e7e5631f819/14be6/8.png"/></picture>
<p>Axiosin metodi <em>get</em> palauttaa <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises">promisen</a>.</p>
<p>Mozillan dokumentaatio sanoo promisesta seuraavaa:</p>
<blockquote>
<p>A Promise is an object representing the eventual completion or failure of an asynchronous operation.</p>
</blockquote>
<p>Promise siis edustaa asynkronista operaatiota. Promise voi olla kolmessa eri tilassa:</p>
<ul>
<li>aluksi promise on <em>pending</em>, eli promisea vastaava asynkroninen operaatio ei ole vielä tapahtunut</li>
<li>jos operaatio päättyy onnistuneesti, menee promise tilaan <em>fulfilled</em>, josta joskus käytetään nimitystä <em>resolved</em></li>
<li>kolmas mahdollinen tila on <em>rejected</em>, joka edustaa epäonnistunutta operaatiota</li>
</ul>
<p>Esimerkkimme ensimmäinen promise on <em>fulfilled</em>, eli vastaa onnistunutta <em>axios.get(&#x27;<a href="http://localhost:3001/notes&#x27;">http://localhost:3001/notes&#x27;</a>)</em> pyyntöä. Promiseista toinen taas on <em>rejected</em>, syy selviää konsolista, eli yritettiin tehdä HTTP GET -pyyntöä osoitteeseen, jota ei ole olemassa.</p>
<p>Jos ja kun haluamme tietoon promisea vastaavan operaation tuloksen, tulee promiselle rekisteröidä tapahtumankuuntelija. Tämä tapahtuu metodilla <em>then</em>:</p>
<pre><code class="language-js">const promise = axios.get(&#x27;http://localhost:3001/notes&#x27;);

promise.then(response =&gt; {
  console.log(response);
});
</code></pre>
<p>Konsoliin tulostuu seuraavaa</p>
<picture><img style="border-color:#EB8755" alt="asd" src="/static/4426ab24bfa41ec484b8d69ccb7f8328/14be6/9.png"/></picture>
<p>Javascriptin suoritusympäristö kutsuu <em>then</em>-metodin avulla rekisteröityä takaisinkutsufunktiota antaen sille parametriksi olion <em>result</em>, joka sisältää kaiken oleellisen HTTP GET -pyynnön vastaukseen liittyvän, eli palautetun <em>datan</em>, <em>statuskoodin</em> ja <em>headerit</em>.</p>
<p>Promise-olioa ei ole yleensä tarvetta tallettaa muuttujaan, ja onkin tapana ketjuttaa metodin <em>then</em> kutsu suoraan axiosin metodin kutsun perään:</p>
<pre><code class="language-js">axios.get(&#x27;http://localhost:3001/notes&#x27;).then(response =&gt; {
  const notes = response.data;
  console.log(notes);
});
</code></pre>
<p>Takaisinkutsufunktio ottaa nyt vastauksen sisällä olevan datan muuttujaan ja tulostaa muistiinpanot konsoliin.</p>
<p>Luettavampi tapa formatoida <em>ketjutettuja</em> metodikutsuja on sijoittaa jokainen kutsu omalle rivilleen:</p>
<pre><code class="language-js">axios.get(&#x27;http://localhost:3001/notes&#x27;).then(response =&gt; {
  const notes = response.data;
  console.log(notes);
});
</code></pre>
<p>näin jo nopea, ruudun vasempaan laitaan kohdistunut vilkaisu kertoo mistä on kyse.</p>
<p>Palvelimen palauttama data on pelkkää tekstiä, käytännössä yksi iso merkkijono. Asian voi todeta, esim. tekemällä HTTP-pyyntö komentoriviltä <a href="https://curl.haxx.se">curl</a>:illa</p>
<picture><img style="border-color:#EB8755" alt="asd" src="/static/e094a975ba60f5ec62e789472e502275/14be6/10.png"/></picture>
<p>Axios-kirjasto osaa kuitenkin parsia datan Javascript-taulukoksi, sillä palvelin on kertonut headerin <em>content-type</em> avulla että datan muoto on <em>application/json; charset=utf-8</em> (ks ylempi kuva).</p>
<p>Voimme vihdoin siirtyä käyttämään sovelluksessamme palvelimelta haettavaa dataa.</p>
<p>Tehdään se aluksi &quot;huonosti&quot;, eli lisätään sovellusta vastaavan komponentin <em>App</em> renderöinti takaisinkutsufunktion sisälle muuttamalla <em>index.js</em> seuraavaan muotoon:</p>
<pre><code class="language-react">import ReactDOM from &#x27;react-dom&#x27;
import React from &#x27;react&#x27;
import App from &#x27;./App&#x27;

import axios from &#x27;axios&#x27;

axios.get(&#x27;http://localhost:3001/notes&#x27;).then(response =&gt; {
  const notes = response.data
  ReactDOM.render(
    &lt;App notes={notes} /&gt;,
    document.getElementById(&#x27;root&#x27;)
  )
})
</code></pre>
<p>Joissain tilanteissa tämäkin tapa voisi olla ok, mutta se on hieman ongelmallinen ja päätetäänkin siirtää datan hakeminen komponenttiin <em>App</em>.</p>
<p>Ei ole kuitenkaan ihan selvää, mihin kohtaan komponentin koodia komento <em>axios.get</em> olisi hyvä sijoittaa.</p>
<h3>Komponenttien lifecycle-metodit</h3>
<p>Reactin luokkien avulla määritellyillä komponenteilla voidaan määritellä joukko <a href="https://reactjs.org/docs/state-and-lifecycle.html#adding-lifecycle-methods-to-a-class">lifecycle</a>-metodeita, eli metodeita, joita React kutsuu tietyssä komponentin &quot;elinkaaren&quot; vaiheessa.</p>
<p>Yleinen tapa datan palvelimelta tapahtuvaan hakemiseen on suorittaa se metodissa <a href="https://reactjs.org/docs/react-component.html#componentdidmount">componentDidMount</a>. React kutsuu metodia sen jälkeen kun konstruktori on suoritettu ja <em>render</em>-metodi on suoritettu ensimmäistä kertaa.</p>
<p>Muutetaan sovellusta nyt seuraavasti.</p>
<p>Poistetaan datan hakeminen tiedostosta <em>index.js</em>:</p>
<pre><code class="language-js">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;));
</code></pre>
<p>Komponentille <em>App</em> ei ole enää tarvetta välittää dataa propseina.</p>
<p>Komponentti <em>App</em> muuttuu seuraavasti:</p>
<pre><code class="language-react">import React from &#x27;react&#x27;
import axios from &#x27;axios&#x27;

class App extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      notes: [],
      newNote: &#x27;&#x27;,
      showAll: true
    }
    console.log(&#x27;constructor&#x27;)
  }

  componentDidMount() {
    console.log(&#x27;did mount&#x27;)
    axios
      .get(&#x27;http://localhost:3001/notes&#x27;)
      .then(response =&gt; {
        console.log(&#x27;promise fulfilled&#x27;)
        this.setState({ notes: response.data })
      })
  }

  render() {
    console.log(&#x27;render&#x27;)
    // ...
  }
}
</code></pre>
<p>Eli konstruktorissa asetetaan tilan <em>notes</em> kentäksi tyhjä taulukko. Lifecycle-metodi <em>componentDidMount</em> hakee datan axiosin avulla ja rekisteröi takaisinkutsufunktion, joka promisen valmistumisen (<em>fulfillment</em>) yhteydessä päivittää komponentin tilan asettamalla palvelimen palauttamat muistiinpanot tilan kentän <em>notes</em> arvoksi.</p>
<p>Koodiin on myös lisätty muutama aputulostus, jotka auttavat hahmottamaan miten suoritus etenee.</p>
<p>Konsoliin tulostuu</p>
<pre>

constructor
render
did mount
promise fulfilled
render
</pre>
<p>Ensin siis suoritetaan konstruktori ja metodi <em>render</em>, ja sen jälkeen metodi <em>componentDidMount</em>. Tämän jälkeen kutsutaan kuitenkin vielä metodia <em>render</em>; miksi näin?</p>
<p>Metodissa <em>componentDidMount</em> suoritetaan axiosin avulla HTTP GET -pyyntö ja samalla <em>rekisteröidään</em> pyynnön palauttamalle promiselle tapahtumankäsittelijä:</p>
<pre><code class="language-js">axios.get(&#x27;http://localhost:3001/notes&#x27;).then(response =&gt; {
  console.log(&#x27;promise fulfilled&#x27;);
  this.setState({ notes: response.data });
});
</code></pre>
<p>Tapahtumankäsittelijän koodia, eli then:in parametrina olevaa <em>funktiota</em> ei siis suoriteta vielä tässä vaiheessa. Javascriptin runtime kutsuu sitä jossain vaiheessa sen jälkeen kun palvelin on vastannut HTTP GET -pyyntöön.</p>
<p>Kun kutsutaan metodia <em>render</em> ensimmäistä kertaa (heti konstruktorin jälkeen) komponentti <em>App</em> piirtyy ruudulle aluksi siten, että yhtään muistiinpanoa ei näytetä. Emme kuitenkaan ehdi huomaamaan asiaa, sillä palvelimen vastaus tulee pian, ja se taas saa aikaan tapahtumankäsittelijän suorituksen. Tapahtumankäsittelijä päivittää komponentin tilaa kutsumalla <em>setState</em> ja tämä saa aikaan komponentin uudelleenrenderöinnin.</p>
<p>Mieti tarkasti äsken läpikäytyä tapahtumasarjaa, sen ymmärtäminen on erittäin tärkeää!</p>
<p>Huomaa, että olisimme voineet kirjoittaa koodin myös seuraavasti:</p>
<pre><code class="language-js">const eventHandler = response =&gt; {
  console.log(&#x27;promise fulfilled&#x27;);
  this.setState({ notes: response.data });
};

const promise = axios.get(&#x27;http://localhost:3001/notes&#x27;);

promise.then(eventHandler);
</code></pre>
<p>Muuttujaan <em>eventHandler</em> on sijoitettu viite funktioon. Axiosin metodin get palauttama promise on talletettu muuttujaan <em>promise</em>. Takaisinkutsun rekisteröinti tapahtuu antamalla promisen then-metodin parametrina muuttuja <em>eventHandler</em>, joka viittaa käsittelijäfunktioon.</p>
<p>React-komponenteilla on myös joukko muita <a href="https://reactjs.org/docs/react-component.html">lifecycle-metodeja</a>, palaamme niihin myöhemmin.</p>
<p>Kokeillaan mitä tapahtuu, jos muistiinpanojen tallettavaa kenttää <em>notes</em> ei alusteta konstruktorissa:</p>
<pre><code class="language-js">class App extends React.Component {
  constructor() {
    super();
    this.state = {
      //notes: [],
      newNote: &#x27;&#x27;,
      showAll: true,
    };
  }

  // ...
}
</code></pre>
<p>Seurauksena on ongelmia:</p>
<picture><img style="border-color:#EB8755" alt="asd" src="/static/872ed9895b9514a24a76a0b3ef59988e/14be6/10a.png"/></picture>
<p>Virheen aiheuttaa komento <em>notesToShow.map</em> sillä muuttujan <em>notesToShow</em> arvo ei ole määritelty ja näin ollen metodin <em>map</em> kutsuminen on mahdotonta.</p>
<p>Muuttuja saa arvonsa metodin <em>render</em> alkuosassa:</p>
<pre><code>const notesToShow =
  this.state.showAll ?
    this.state.notes :
    this.state.notes.filter(note =&gt; note.important === true)
</code></pre>
<p>Koska metodia <em>render</em> kutsutaan ensimmäisen kerran <em>ennen kuin palvelimelta haettava data saapuu</em>, ei tilan kentälle <em>notes</em> ole asetettu mitään arvoa.</p>
<p>Tulet 100% varmuudella törmäämään kurssilla vastaavaan ongelmaan, eli <em>render</em> metodissa on jollain tavalla aina varauduttava siihen, että ensimmäinen renderöitymiskerta tapahtuu ennen kuin palvelimelta haettava data on saapunut.</p>
<p>Palautetaan konstruktori ennalleen.</p>
<p>Sovelluksen tämän hetkinen koodi on kokonaisuudessaan <a href="https://github.com/FullStack-HY/part2-notes/tree/part2-4">githubissa</a>, tagissa <em>part2-4</em>.</p>
</div></div>
<div class="banner spacing spacing--after" style="background-color:#EB8755"><div class="container"><div class="course-content col-7 push-right-3">
<h3>Tehtävät 2.11</h3>
<h4>puhelinluettelo osa 6</h4>
<p>Talleta sovelluksen alkutila projektin juureen sijoitettavaan tiedostoon <em>db.json</em>:</p>
<pre><code class="language-json">{
  &quot;persons&quot;: [
    {
      &quot;name&quot;: &quot;Arto Hellas&quot;,
      &quot;number&quot;: &quot;040-123456&quot;,
      &quot;id&quot;: 1
    },
    {
      &quot;name&quot;: &quot;Martti Tienari&quot;,
      &quot;number&quot;: &quot;040-123456&quot;,
      &quot;id&quot;: 2
    },
    {
      &quot;name&quot;: &quot;Arto Järvinen&quot;,
      &quot;number&quot;: &quot;040-123456&quot;,
      &quot;id&quot;: 3
    },
    {
      &quot;name&quot;: &quot;Lea Kutvonen&quot;,
      &quot;number&quot;: &quot;040-123456&quot;,
      &quot;id&quot;: 4
    }
  ]
}
</code></pre>
<p>Käynnistä json-server porttiin 3001 ja varmista selaimella osoitteesta <a href="http://localhost:3001/persons">http://localhost:3001/persons</a>, että palvelin palauttaa henkilölistan.</p>
<p>Jos saat virheilmoituksen:</p>
<pre><code class="language-bash">events.js:182
      throw er; // Unhandled &#x27;error&#x27; event
      ^

Error: listen EADDRINUSE 0.0.0.0:3001
    at Object._errnoException (util.js:1019:11)
    at _exceptionWithHostPort (util.js:1041:20)
</code></pre>
<p>on portti 3001 jo jonkin muun sovelluksen, esim. jo käynnissä olevan json-serverin käytössä. Sulje toinen sovellus tai jos se ei onnistu, vaihda porttia.</p>
<p>Muuta sovellusta siten, että datan alkutila haetaan <em>axios</em>-kirjaston avulla palvelimelta. Hoida datan hakeminen <a href="/osa2#komponenttien-lifecycle-metodit">lifecyclemetodissa</a> <em>componentDidMount</em>.</p>
<h3>Tehtävät 2.12*</h3>
<h4>maiden tiedot</h4>
<p>Rajapinta <a href="https://restcountries.eu">https://restcountries.eu</a> tarjoaa paljon eri maihin liittyvää tietoa koneluettavassa muodossa REST-apina.</p>
<p>Tee sovellus, jonka avulla voit tarkastella eri maiden tietoja. Sovelluksen kannattaa hakea tiedot endpointista <a href="https://restcountries.eu/#api-endpoints-all">all</a>.</p>
<p>Sovelluksen käyttöliittymä on yksinkertainen. Näytettävä maa haetaan kirjoittamalla hakuehto etsintäkenttään.</p>
<p>Jos ehdon täyttäviä maita on liikaa (yli 10), kehoitetaan tarkentamaan hakuehtoa:</p>
<picture><img style="border-color:#EB8755" alt="asd" src="/static/a47ea7bcd82b8c8848e16c0c6fb3617d/14be6/13.png"/></picture>
<p>Jos maita on alle kymmenen, mutta yli 1 näytetään hakuehdon täyttävät maat:</p>
<picture><img style="border-color:#EB8755" alt="asd" src="/static/21c45c6fd07f9da013cab54bdf8935f5/14be6/14.png"/></picture>
<p>Kun ehdon täyttäviä maita on enää yksi, näytetään maan lippu sekä perustiedot:</p>
<picture><img style="border-color:#EB8755" alt="asd" src="/static/4f93ad869b80169444bfff56175c3d1c/14be6/15.png"/></picture>
<p><strong>Huom:</strong> riittää että sovelluksesi toimii suurimmalle osalle maista. Jotkut maat kuten <em>Sudan</em> voivat tuottaa ongelmia, sillä maan nimi on toisen maan <em>South Sudan</em> osa. Näistä corner caseista ei tarvitse välittää.</p>
<h3>Tehtävät 2.13*</h3>
<h4>puhelinluettelo osa 4</h4>
<p><strong>Älä juutu tähän tehtävään!</strong></p>
<p>Paranna edellisen tehtävän maasovellusta siten, että kun sivulla näkyy useiden maiden nimiä, riittää maan nimen klikkaaminen tarkentamaan haun siten, että klikatun maan tarkemmat tiedot saadaan näkyviin.</p>
<p>Huomaa, että saat &quot;nimestä&quot; klikattavan kiinnittämällä nimen sisältävään elementtiin, esim. diviin klikkaustenkuuntelijan:</p>
<pre><code>&lt;div onClick={...}&gt;
  {country.name}
&lt;/div&gt;
</code></pre>
</div></div></div>
<div class="container"><div class="scroll-navigation col-3 element--flex element--column"></div><div class="course-content col-7">
<h2>REST API:n käyttö</h2>
<p>Kun sovelluksella luodaan uusia muistiinpanoja, täytyy ne tallentaa palvelimelle.</p>
<p>json-server mainitsee olevansa ns. REST tai RESTful API</p>
<blockquote>
<p>Get a full fake REST API with zero coding in less than 30 seconds (seriously)</p>
</blockquote>
<p>Ihan alkuperäisen <a href="https://en.wikipedia.org/wiki/Representational_state_transfer">määritelmän</a> mukainen RESTful API json-server ei ole, mutta ei ole kovin moni muukaan itseään REST:iksi kutsuva rajapinta.</p>
<p>Tutustumme REST:iin tarkemmin kurssin <a href="/osa3">seuraavassa osassa</a>, mutta jo nyt on tärkeä ymmärtää minkälaista <a href="https://en.wikipedia.org/wiki/Representational_state_transfer#Applied_to_Web_services">konventiota</a> json-server ja yleisemminkin REST API:t käyttävät <a href="https://github.com/typicode/json-server#routes">reittien</a>, eli URL:ien ja käytettävien HTTP-pyyntöjen tyyppien suhteen.</p>
<p>REST:issä yksittäisiä asioita esim. meidän tapauksessamme muistiinpanoja kutsutaan <em>resursseiksi</em>. Jokaisella resurssilla on yksilöivä osoite eli URL. json-serverin noudattaman yleisen konvention mukaan yksittäistä muistiinpanoa kuvaavan resurssin URL on muotoa <em>notes/3</em>, missä 3 on resurssin tunniste. Osoite <em>notes</em> taas vastaa kaikkien yksittäisten muistiinpanojen kokoelmaa.</p>
<p>Resursseja haetaan palvelimelta HTTP GET -pyynnöillä. Esim. HTTP GET osoitteeseen <em>notes/3</em> palauttaa muistiinpanon, jonka id-kentän arvo on 3. Kun taas HTTP GET -pyyntö osoitteeseen <em>notes</em> palauttaa kaikki muistiinpanot.</p>
<p>Uuden muistiinpanoa vastaavan resurssin luominen tapahtuu json-serverin noudattamassa REST-konventiossa tekemällä HTTP POST -pyyntö, joka kohdistuu myös samaan osoitteeseen <em>notes</em>. Pyynnön mukana sen runkona eli <em>bodynä</em> lähetetään luotavan muistiinpanon tiedot.</p>
<p>json-server vaatii, että tiedot lähetetään JSON-muodossa, eli käytännössä sopivasti muotoiltuna merkkijonona ja asettamalla headerille <em>Content-Type</em> arvo <em>application/json</em>.</p>
<h2>Datan lähetys palvelimelle</h2>
<p>Muutetaan nyt uuden muistiinpanon lisäämisestä huolehtivaa tapahtumankäsittelijää seuraavasti:</p>
<pre><code class="language-js">addNote = event =&gt; {
  event.preventDefault();
  const noteObject = {
    content: this.state.newNote,
    date: new Date(),
    important: Math.random() &gt; 0.5,
  };

  axios.post(&#x27;http://localhost:3001/notes&#x27;, noteObject).then(response =&gt; {
    console.log(response);
  });
};
</code></pre>
<p>eli luodaan muistiinpanoa vastaava olio, ei kuitenkaan lisätä sille kenttää <em>id</em>, parempi jättää id:n generointi palvelimen vastuulle!</p>
<p>Lähetetään sitten olio palvelimelle käyttämällä axiosin metodia <em>post</em>. Rekisteröidään tapahtumankäsittelijä, joka tulostaa konsoliin palvelimen vastauksen.</p>
<p>Kun nyt kokeillaan luoda uusi muistiinpano, konsoliin tulostus näyttää seuraavalta:</p>
<picture><img style="border-color:#EB8755" alt="asd" src="/static/60f7c022db4db463b5a634e05acde7ad/14be6/11.png"/></picture>
<p>Uusi muistiinpano on siis <em>response</em>-olion kentän <em>data</em> arvona. Palvelin on lisännyt muistiinpanolle tunnisteen, eli <em>id</em>-kentän.</p>
<p>Joskus on hyödyllistä tarkastella HTTP-pyyntöjä <a href="/osa0#http-get">osan 0 alussa</a> paljon käytetyn konsolin <em>Network</em>-välilehden kautta:</p>
<picture><img style="border-color:#EB8755" alt="asd" src="/static/d2ccd9eb946dce179331c3b7b077d8d9/14be6/12.png"/></picture>
<p>Voimme esim. tarkastaa onko POST-pyynnön mukana menevä data juuri se mitä oletimme, onko headerit asetettu oikein ym.</p>
<p>Koska POST-pyynnössä lähettämämme data oli Javascript-olio, osasi axios automaattisesti asettaa pyynnön <em>content-type</em> headerille oikean arvon eli <em>application/json</em>.</p>
<p>Uusi muistiinpano ei vielä renderöidy ruudulle, sillä emme aseta komponentille <em>App</em> uutta tilaa muistiinpanon luomisen yhteydessä. Viimeistellään sovellus vielä tältä osin:</p>
<pre><code class="language-js">addNote = event =&gt; {
  event.preventDefault();
  const noteObject = {
    content: this.state.newNote,
    date: new Date(),
    important: Math.random() &gt; 0.5,
  };

  axios.post(&#x27;http://localhost:3001/notes&#x27;, noteObject).then(response =&gt; {
    this.setState({
      notes: this.state.notes.concat(response.data),
      newNote: &#x27;&#x27;,
    });
  });
};
</code></pre>
<p>Palvelimen palauttama uusi muistiinpano siis lisätään tilassa olevien muiden muistiinpanojen joukkoon (kannattaa <a href="/osa1#taulukon-k%C3%A4sittely%C3%A4">muistaa tärkeä detalji</a> siitä, että metodi <em>concat</em> ei muuta komponentin alkuperäistä tilaa, vaan luo uuden taulukon) ja tyhjennetään lomakkeen teksti.</p>
<p>Kun palvelimella oleva data alkaa vaikuttaa web-sovelluksen toimintalogiikkaan, tulee sovelluskehitykseen heti iso joukko uusia haasteita, joita tuo mukanaan mm. kommunikoinnin asynkronisuus. Debuggaamiseenkin tarvitaan uusia strategiota, debug-printtaukset ym. muuttuvat vain tärkeämmäksi, myös Javascriptin runtimen periaatteita ja React-komponenttien elinkaarta on pakko tuntea riittävällä tasolla, arvaileminen ei riitä.</p>
<p>Palvelimen tilaa kannattaa tarkastella myös suoraan, esim. selaimella:</p>
<picture><img style="border-color:#EB8755" alt="asd" src="/static/352d93979ae65852217997909ddbe704/14be6/13.png"/></picture>
<p>näin on mahdollista varmistua, mm. siirtyykö kaikki oletettu data palvelimelle.</p>
<p>Kurssin seuraavassa osassa alamme toteuttaa itse myös palvelimella olevan sovelluslogiikan, tutustumme silloin tarkemmin palvelimen debuggausta auttaviin työkaluihin, mm. <a href="https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop">postmaniin</a>. Tässä vaiheessa json-server-palvelimen tilan tarkkailuun riittänee selain.</p>
<blockquote>
<p><strong>HUOM:</strong> sovelluksen nykyisessä versiossa selain lisää uudelle muistiinpanolle sen luomishetkeä kuvaavan kentän. Koska koneen oma kello voi näyttää periaatteessa mitä sattuu, on aikaleimojen generointi todellisuudessa viisaampaa hoitaa palvelimella ja tulemmekin tekemään tämän muutoksen kurssin seuraavassa osassa.</p>
</blockquote>
<p>Sovelluksen tämän hetkinen koodi on kokonaisuudessaan <a href="https://github.com/FullStack-HY/part2-notes/tree/part2-5">githubissa</a>, tagissa <em>part2-5</em>.</p>
<h2>Muistiinpanon tärkeyden muutos</h2>
<p>Lisätään muistiinpanojen yhteyteen painike, millä niiden tärkeyttä voi muuttaa.</p>
<p>Muistiinpanon määrittelevän komponentin muutos on seuraava:</p>
<pre><code class="language-js">const Note = ({ note, toggleImportance }) =&gt; {
  const label = note.important ? &#x27;make not important&#x27; : &#x27;make important&#x27;;
  return (
    &lt;li&gt;
      {note.content} &lt;button onClick={toggleImportance}&gt;{label}&lt;/button&gt;
    &lt;/li&gt;
  );
};
</code></pre>
<p>Komponentissa on nappi, jolle on rekisteröity klikkaustapahtuman käsittelijäksi propsien avulla välitetty funktio <em>toggleImportance</em>.</p>
<p>Tapahtumankäsittelijän alustava versio on määritelty komponentissa <em>App</em> seuraavasti:</p>
<pre><code class="language-js">toggleImportanceOf = id =&gt; {
  return () =&gt; {
    console.log(&#x27;importance of &#x27; + id + &#x27; needs to be toggled&#x27;);
  };
};
</code></pre>
<p>Kyseessä on jälleen funktio, joka palauttaa funktion. Palataan sen sisältöön kohta.</p>
<p>Komponentin <em>App</em> metodissa <em>render</em> välitetään jokaiselle muistiinpanolle tapahtumankäsittelijäfunktio:</p>
<pre><code class="language-html">&lt;ul&gt;
  {notesToShow.map(note =&gt;
    &lt;Note
      key={note.id}
      note={note}
      toggleImportance={this.toggleImportanceOf(note.id)}
    /&gt;
  )}
&lt;/ul&gt;
</code></pre>
<p>Jokaisen muistiinpanon tapahtumankäsittelijä on nyt <em>yksilöllinen</em>, sillä se sisältää muistiinpanon <em>id:n</em>. Esim. jos <em>note.id</em> on 3 tulee tapahtumankäsittelijäksi <em>this.toggleImportance(note.id)</em> eli käytännössä:</p>
<pre><code class="language-js">() =&gt; {
  console.log(&#x27;importance of 3 needs to be toggled&#x27;);
};
</code></pre>
<p>Eli komponentin <em>App</em> metodi <em>toggleImportanceOf</em> ei itsessään ole tapahtumankäsittelijä, vaan <em>tehdas</em>, jonka avulla kullekin muistiinpanolle luodaan oma tapahtumankäsittelijä.</p>
<p>Pieni huomio tähän väliin. Tapahtumankäsittelijän koodin tulostuksessa muodostetaan tulostettava merkkijono Javan tyyliin plussaamalla stringejä:</p>
<pre><code class="language-js">console.log(&#x27;importance of &#x27; + id + &#x27; needs to be toggled&#x27;);
</code></pre>
<p>ES6:n <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">template string</a> -ominaisuuden ansiosta Javascriptissa vastaavat merkkijonot voidaan kirjottaa hieman mukavammin:</p>
<pre><code class="language-js">console.log(`importance of ${id} needs to be toggled`);
</code></pre>
<p>Merkkijonon sisälle voi nyt määritellä &quot;dollari-aaltosulku&quot;-syntaksilla kohtia, minkä sisälle evaluoidaan javascript-lausekkeita, esim. muuttujan arvo. Huomaa, että template stringien hipsutyyppi poikkeaa Javascriptin normaaleista merkkijonojen käyttämistä hipsuista.</p>
<p>Yksittäistä json-serverillä olevaa muistiinpanoa voi muuttaa kahdella tavalla, joko <em>korvaamalla</em> sen tekemällä HTTP PUT -pyyntö muistiinpanon yksilöivään osoitteeseen tai muuttamalla ainoastaan joidenkin muistiinpanon kenttien arvoja HTTP PATCH -pyynnöllä.</p>
<p>Korvaamme nyt muistiinpanon kokonaan, sillä samalla tulee esille muutama tärkeä React:iin ja Javascriptiin liittyvä seikka.</p>
<p>Metodi on seuraavassa:</p>
<pre><code class="language-js">toggleImportanceOf = id =&gt; {
  return () =&gt; {
    const url = `http://localhost:3001/notes/${id}`;
    const note = this.state.notes.find(n =&gt; n.id === id);
    const changedNote = { ...note, important: !note.important };

    axios.put(url, changedNote).then(response =&gt; {
      this.setState({
        notes: this.state.notes.map(note =&gt;
          note.id !== id ? note : response.data
        ),
      });
    });
  };
};
</code></pre>
<p>Melkein joka riville sisältyy tärkeitä yksityiskohtia. Ensimmäinen rivi määrittelee jokaiselle muistiinpanolle id-kenttään perustuvan yksilöivän url:in.</p>
<p>Taulukon metodilla <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find">find</a> etsitään muutettava muistiinpano ja talletetaan muuttujaan <em>note</em> viite siihen.</p>
<p>Sen jälkeen luodaan <em>uusi olio</em>, jonka sisältö on sama kuin vanhan olion sisältö poislukien kenttä important. Luominen näyttää hieman erikoiselta:</p>
<pre><code class="language-js">const changedNote = { ...note, important: !note.important };
</code></pre>
<p>Kyseessä on vielä standardoimattoman <a href="https://github.com/tc39/proposal-object-rest-spread">object spread</a> -operaation soveltaminen.</p>
<p>Käytännössä <code>{...note}</code> luo olion, jolla on kenttinään kopiot olion <em>note</em> kenttien arvoista. Kun aaltosulkeisiin lisätään asioita, esim. <code>{ ...note, important: true }</code>, tulee uuden olion kenttä <em>important</em> saamaan arvon <em>true</em>. Eli esimerkissämme <em>important</em> saa uudessa oliossa vanhan arvonsa käänteisarvon.</p>
<p>Uusi olio olisi voitu luoda myös vanhemmalla komennolla <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign</a></p>
<pre><code class="language-js">const changedNote = Object.assign({}, note, {important: !note.important} }
</code></pre>
<p>Object spread -syntaksi on kuitenkin yleisesti käytössä Reactissa, joten mekin käytämme sitä.</p>
<p>Pari huomioita. Miksi teimme muutettavasta oliosta kopion vaikka myös seuraava koodi näyttää toimivan:</p>
<pre><code class="language-js">const note = this.state.notes.find(n =&gt; n.id === id)
note.important = !note.important

axios.put(url, note).then(response =&gt; {
</code></pre>
<p>Näin ei ole suositetavaa tehdä, sillä muuttuja <em>note</em> on viite komponentin tilassa, eli <em>this.state.notes</em>-taulukossa olevaan olioon, ja kuten muistamme tilaa ei Reactissa saa muuttaa suoraan!</p>
<p>Kannattaa myös huomata, että uusi olio <em>changedNote</em> on ainoastaan ns <a href="https://en.wikipedia.org/wiki/Object_copying#Shallow_copy">shallow copy</a>, eli uuden olion kenttien arvoina on vanhan olion kenttien arvot. Jos vanhan olion kentät olisivat itsessään olioita, viittaisivat uuden olion kentät samoihin olioihin.</p>
<p>Uusi muistiinpano lähetetään sitten PUT-pyynnön mukana palvelimelle, jossa se korvaa aiemman muistiinpanon.</p>
<p>Takaisinkutsufunktiossa asetetaan komponentin <em>App</em> tilaan kaikki vanhat muistiinpanot paitsi muuttuneen, josta tilaan asetetaan palvelimen palauttama versio:</p>
<pre><code class="language-js">axios.put(url, changedNote).then(response =&gt; {
  this.setState({
    notes: this.state.notes.map(note =&gt;
      note.id !== id ? note : response.data
    ),
  });
});
</code></pre>
<p>Tämä saadaan aikaan metodilla <em>map</em> joka siis luo uuden taulukon vanhan taulukon perusteella. Jokainen uuden taulukon alkio luodaan ehdollisesti siten, että jos ehto <em>note.id !== id</em> on tosi, otetaan uuteen taulukkoon suoraan vanhan taulukon kyseinen alkio. Jos ehto on epätosi, eli kyseessä on muutettu muistiinpano, otetaan uuteen taulukkoon palvelimen palauttama olio.</p>
<p>Käytetty <em>map</em>-kikka saattaa olla aluksi hieman hämmentävä. Asiaa kannattaakin miettiä tovi. Tapaa tullaan käyttämään kurssilla vielä kymmeniä kertoja.</p>
<h2>Palvelimen kanssa tapahtuvan kommunikoinnin eristäminen omaan moduuliin</h2>
<p><em>App</em>-komponentti alkaa kasvaa uhkaavasti kun myös palvelimen kanssa kommunikointi tapahtuu komponentissa. <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">Single responsibility</a> -periaatteen hengessä kommunikointi onkin viisainta eristää omaan <a href="#refaktorointia---moduulit">moduuliinsa</a>.</p>
<p>Luodaan hakemisto <em>src/services</em> ja sinne tiedosto <em>notes.js</em>:</p>
<pre><code class="language-js">import axios from &#x27;axios&#x27;;
const baseUrl = &#x27;http://localhost:3001/notes&#x27;;

const getAll = () =&gt; {
  return axios.get(baseUrl);
};

const create = newObject =&gt; {
  return axios.post(baseUrl, newObject);
};

const update = (id, newObject) =&gt; {
  return axios.put(`${baseUrl}/${id}`, newObject);
};

export default { getAll, create, update };
</code></pre>
<p>Moduuli palauttaa nyt olion, jonka kenttinä on kolme muistiinpanojen käsittelyä hoitavaa funktiota. Funktiot palauttavat suoraan axiosin metodien palauttaman promisen.</p>
<p>Komponentti <em>App</em> saa moduulin käyttöön <em>import</em>-lauseella</p>
<pre><code class="language-js">import noteService from &#x27;./services/notes&#x27;

App extends React.Component {
</code></pre>
<p>moduulin funktioita käytetään importatun muuttujan <em>noteService</em> kautta seuraavasti:</p>
<pre><code class="language-js">componentDidMount() {
  noteService
    .getAll()
    .then(response =&gt; {
      this.setState({notes: response.data})
    })
}

addNote = (event) =&gt; {
  // ...
  noteService
    .create(noteObject)
    .then(response =&gt; {
      this.setState({
        notes: this.state.notes.concat(response.data),
        newNote: &#x27;&#x27;
      })
    })
}

toggleImportanceOf = (id) =&gt; {
  return () =&gt; {
    // ...
    noteService
      .update(id, changedNote)
      .then(response =&gt; {
        this.setState({
          notes: this.state.notes.map(note =&gt; note.id !== id ? note : response.data)
        })
      })
  }
}
</code></pre>
<p>Voisimme viedä ratkaisua vielä askeleen pidemmälle, sillä käyttäessään moduulin funktioita komponentti <em>App</em> saa olion, joka sisältää koko HTTP-pyynnön vastauksen:</p>
<pre><code class="language-js">noteService.getAll().then(response =&gt; {
  this.setState({ notes: response.data });
});
</code></pre>
<p>Eli asia mistä <em>App</em> on kiinnostunut on parametrin kentässä <em>response.data</em>.</p>
<p>Moduulia olisi miellyttävämpi käyttää, jos se HTTP-pyynnön vastauksen sijaan palauttaisi suoraan muistiinpanot sisältävän taulukon. Tällöin moduulin käyttö näyttäisi seuraavalta</p>
<pre><code class="language-js">noteService.getAll().then(notes =&gt; {
  this.setState({ notes: notes });
});
</code></pre>
<p>joka voitaisiin <a href="#kehittyneempi-tapa-olioliteraalien-kirjoittamiseen">ilmaista hieman tiiviimmin</a> seuraavasti:</p>
<pre><code class="language-js">noteService.getAll().then(notes =&gt; {
  this.setState({ notes });
});
</code></pre>
<p>Tämä onnistuu muuttamalla moduulin koodia seuraavasti (koodiin jää ikävästi copy-pastea, emme kuitenkaan nyt välitä siitä):</p>
<pre><code class="language-js">import axios from &#x27;axios&#x27;;
const baseUrl = &#x27;http://localhost:3001/notes&#x27;;

const getAll = () =&gt; {
  const request = axios.get(baseUrl);
  return request.then(response =&gt; response.data);
};

const create = newObject =&gt; {
  const request = axios.post(baseUrl, newObject);
  return request.then(response =&gt; response.data);
};

const update = (id, newObject) =&gt; {
  const request = axios.put(`${baseUrl}/${id}`, newObject);
  return request.then(response =&gt; response.data);
};

export default { getAll, create, update };
</code></pre>
<p>eli enää ei palautetakaan suoraan axiosin palauttamaa promisea, vaan otetaan promise ensin muuttujaan <em>request</em> ja kutsutaan sille metodia <em>then</em>:</p>
<pre><code class="language-js">const getAll = () =&gt; {
  const request = axios.get(baseUrl);
  return request.then(response =&gt; response.data);
};
</code></pre>
<p>Täydellisessä muodossa kirjoitettuna viimeinen rivi olisi:</p>
<pre><code class="language-js">const getAll = () =&gt; {
  const request = axios.get(baseUrl);
  return request.then(response =&gt; {
    return response.data;
  });
};
</code></pre>
<p>Myös nyt funktio <em>getAll</em> palauttaa promisen, sillä promisen metodi <em>then</em> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then">palauttaa promisen</a>.</p>
<p>Koska <em>then</em>:in parametri palauttaa suoraan arvon <em>response.data</em>, on funktion <em>getAll</em> palauttama promise sellainen, että jos HTTP-kutsu onnistuu, antaa promise takaisinkutsulleen HTTP-pyynnön mukana olleen datan, eli se toimii juuri niin kuin haluamme.</p>
<p>Moduulin muutoksen jälkeen täytyy komponentti <em>App</em> muokata <em>noteService</em>:n metodien takaisinkutsujen osalta ottamaan huomioon, että ne palauttavat datan suoraan:</p>
<pre><code class="language-js">class App extends React.component {
  componentDidMount() {
    noteService.getAll().then(response =&gt; {
      this.setState({ notes: response });
    });
  }

  addNote = event =&gt; {
    // ...
    noteService.create(noteObject).then(newNote =&gt; {
      this.setState({
        notes: this.state.notes.concat(newNote),
        newNote: &#x27;&#x27;,
      });
    });
  };

  toggleImportanceOf = id =&gt; {
    return () =&gt; {
      // ...

      noteService.update(id, changedNote).then(changedNote =&gt; {
        const notes = this.state.notes.filter(n =&gt; n.id !== id);
        this.setState({
          notes: notes.concat(changedNote),
        });
      });
    };
  };
}
</code></pre>
<p>Tämä kaikki on hieman monimutkaista ja asian selittäminen varmaan vaan vaikeuttaa sen ymmärtämistä. Internetistä löytyy paljon vaihtelevatasoista materiaalia aiheesta, esim. <a href="https://javascript.info/promise-chaining">tämä</a>.</p>
<p><a href="https://github.com/getify/You-Dont-Know-JS">You do not know JS</a> sarjan kirja &quot;Async and performance&quot; selittää asian <a href="https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch3.md">hyvin</a> mutta tarvitsee selitykseen kohtuullisen määrän sivuja.</p>
<p>Promisejen ymmärtäminen on erittäin keskeistä modernissa Javascript-sovelluskehityksessä, joten asiaan kannattaa uhrata kohtuullisessa määrin aikaa.</p>
<h2>Promise ja virheet</h2>
<p>Jos sovelluksemme mahdollistaisi muistiinpanojen poistamisen, voisi syntyä tilanne, missä käyttäjä yrittää muuttaa sellaisen muistiinpanon tärkeyttä, joka on jo poistettu järjestelmästä.</p>
<p>Simuloidaan tälläistä tilannetta &quot;kovakoodaamalla&quot; noteServiceen funktioon <em>getAll</em> muistiinpano, jota ei ole todellisuudessa (eli palvelimella) olemassa:</p>
<pre><code class="language-js">const getAll = () =&gt; {
  const request = axios.get(baseUrl);
  const nonExisting = {
    id: 10000,
    content: &#x27;Tätä muistiinpanoa ei ole palvelimelta&#x27;,
    date: &#x27;2017-12-10T17:30:31.098Z&#x27;,
    important: true,
  };
  return request.then(response =&gt; response.data.concat(nonExisting));
};
</code></pre>
<p>Kun valemuistiinpanon tärkeyttä yritetään muuttaa, konsoliin tulee virheilmoitus, joka kertoo palvelimen vastanneen urliin <em>/notes/10000</em> tehtyyn HTTP PUT -pyyntöön statuskoodilla 404 <em>not found</em>:</p>
<picture><img style="border-color:#EB8755" alt="asd" src="/static/2dccb8bbe15f5d18f3416b77104869d0/14be6/14.png"/></picture>
<p>Sovelluksen tulisi pystyä käsittelemään tilanne hallitusti. Jos konsoli ei ole auki, ei käyttäjä huomaa mitään muuta kuin sen, että muistiinpanon tärkeys ei vaihdu napin painelusta huolimatta.</p>
<p>Jo <a href="#axios-ja-promiset">aiemmin</a> mainittiin, että promisella voi olla kolme tilaa. Kun HTTP-pyyntö epäonnistuu, menee pyyntöä vastaava promise tilaan <em>rejected</em>. Emme tällä hetkellä käsittele koodissamme promisen epäonnistumista mitenkään.</p>
<p>Promisen epäonnistuminen <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises">käsitellään</a> antamalla <em>then</em> --metodille parametriksi myös toinen takaisinkutsufunktio, jota kutsutaan siinä tapauksessa jos promise epäonnistuu.</p>
<p>Ehkä yleisempi tapa kuin kahden tapahtumankäsittelijän käyttö on liittää promiseen epäonnistumistilanteen käsittelijä kutsumalla metodia <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch">catch</a>.</p>
<p>Käytännössä virhetilanteen käsittelijän rekisteröiminen tapahtuisi seuraavasti</p>
<pre><code class="language-js">axios
  .get(&#x27;http://example.com/probably_will_fail&#x27;)
  .then(response =&gt; {
    console.log(&#x27;success!&#x27;);
  })
  .catch(error =&gt; {
    console.log(&#x27;fail&#x27;);
  });
</code></pre>
<p>Jos pyyntö epäonnistuu, kutsutaan <em>catch</em>-metodin avulla rekisteröityä käsittelijää.</p>
<p>Metodia <em>catch</em> hyödynnetään usein siten, että se sijoitetaan syvemmälle promiseketjuun.</p>
<p>Kun sovelluksemme tekee HTTP-operaation syntyy oleellisesti ottaen <a href="https://javascript.info/promise-chaining">promiseketju</a>:</p>
<pre><code class="language-js">axios
  .put(`${baseUrl}/${id}`, newObject)
  .then(response =&gt; response.data)
  .then(changedNote =&gt; {
    // ...
  });
</code></pre>
<p>Metodilla <em>catch</em> voidaan määritellä ketjun lopussa käsittelijäfunktio, jota kutsutaan siinä vaiheessa jos mikä tahansa ketjun promisesta epäonnistuu, eli menee tilaan <em>rejected</em>:</p>
<pre><code class="language-js">axios
  .put(`${baseUrl}/${id}`, newObject)
  .then(response =&gt; response.data)
  .then(changedNote =&gt; {
    // ...
  })
  .catch(error =&gt; {
    console.log(&#x27;fail&#x27;);
  });
</code></pre>
<p>Hyödynnetään tätä ominaisuutta, ja sijoitetaan virheenkäsittelijä komponenttiin <em>App</em>:</p>
<pre><code class="language-js">toggleImportanceOf = id =&gt; {
  return () =&gt; {
    const note = this.state.notes.find(n =&gt; n.id === id);
    const changedNote = { ...note, important: !note.important };

    noteService
      .update(id, changedNote)
      .then(changedNote =&gt; {
        const notes = this.state.notes.filter(n =&gt; n.id !== id);
        this.setState({
          notes: notes.concat(changedNote),
        });
      })
      .catch(error =&gt; {
        alert(
          `muistiinpano &#x27;${
            note.content
          }&#x27; on jo valitettavasti poistettu palvelimelta`
        );
        this.setState({ notes: this.state.notes.filter(n =&gt; n.id !== id) });
      });
  };
};
</code></pre>
<p>Virheilmoitus annetaan vanhan kunnon <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/alert">alert</a>-dialogin avulla ja palvelimelta poistettu muistiinpano poistetaan tilasta.</p>
<p>Olemattoman muistiinpanon poistaminen siis tapahtuu metodilla <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">filter</a>, joka muodostaa uuden taulukon, jonka sisällöksi tulee alkuperäisen taulukon sisällöstä ne alkiot, joille parametrina oleva funktio palauttaa arvon true:</p>
<pre><code class="language-js">this.state.notes.filter(n =&gt; n.id !== id) }
</code></pre>
<p>Alertia tuskin kannattaa käyttää todellisissa React-sovelluksissa. Opimme kohta kehittyneemmän menetelmän käyttäjille tarkoitettujen tiedotteiden antamiseen. Toisaalta on tilanteita, joissa simppeli battle tested -menetelmä kuten <em>alert</em> riittää aluksi aivan hyvin. Hienomman tavan voi sitten tehdä myöhemmin jos aikaa ja intoa riittää.</p>
<p>Sovelluksen tämän hetkinen koodi on kokonaisuudessaan <a href="https://github.com/FullStack-HY/part2-notes/tree/part2-6">githubissa</a>, tagissa <em>part2-6</em>.</p>
</div></div>
<div class="banner spacing spacing--after" style="background-color:#EB8755"><div class="container"><div class="course-content col-7 push-right-3">
<h3>Tehtävät 2.14</h3>
<h4>puhelinluettelo osa 7</h4>
<p>Palataan jälleen puhelinluettelon pariin.</p>
<p>Tällä hetkellä luetteloon lisättäviä uusia numeroita ei synkronoida palvelimelle. Korjaa tilanne.</p>
<h3>Tehtävät 2.15</h3>
<h4>puhelinluettelo osa 8</h4>
<p>Siirrä palvelimen kanssa kommunikoinnista vastaava toiminnallisuus omaan moduuliin osan 2 <a href="/osa2/#palvelimen-kanssa-tapahtuvan-kommunikoinnin-erist%C3%A4minen-omaan-moduuliin">esimerkin</a> tapaan.</p>
<h3>Tehtävät 2.16</h3>
<h4>puhelinluettelo osa 9</h4>
<p>Tee ohjelmaan mahdollisuus yhteystietojen poistamiseen. Poistaminen voi tapahtua esim. nimen yhteyteen liitetyllä napilla. Poiston suorittaminen voidaan varmistaa käyttäjältä <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/confirm">window.confirm</a>-metodilla:</p>
<picture><img style="border-color:#EB8755" alt="asd" src="/static/317a917a29c7d9d0860fce84aab3ccd5/14be6/16.png"/></picture>
<p>Palvelimelta tiettyä henkilöä vastaava resurssi tuhotaan tekemällä HTTP DELETE -pyyntö resurssia vastaavaan <em>URL</em>:iin, eli jos poistaisimme esim. käyttäjän, jonka <em>id</em> on 2, tulisi tapauksessamme tehdä HTTP DELETE osoitteeseen <em>localhost:3001/persons/2</em>. Pyynnön mukana ei lähetetä mitään dataa.</p>
<p><a href="https://github.com/axios/axios">Axios</a>-kirjaston avulla HTTP DELETE -pyyntö tehdään samaan tapaan kuin muutkin pyynnöt.</p>
<h3>Tehtävät 2.17*</h3>
<h4>puhelinluettelo osa 10</h4>
<p>Muuta toiminnallisuutta siten, että jos jo olemassaolevalle henkilölle lisätään numero, korvaa lisätty numero aiemman numeron. Korvaaminen kannattaa tehdä HTTP PUT -pyynnöllä.</p>
<p>Jos henkilön tiedot löytyvät jo luettelosta, voi ohjelma kysyä käyttäjältä varmistuksen korvataanko numero:</p>
<picture><img style="border-color:#EB8755" alt="asd" src="/static/651c1945ef229063ffb370db0fcbf80b/14be6/16a.png"/></picture>
</div></div></div>
<div class="container"><div class="scroll-navigation col-3 element--flex element--column"></div><div class="course-content col-7">
<h2>Tyylien lisääminen</h2>
<p>Sovelluksemme ulkoasu on tällä hetkellä hyvin vaatimaton. Osaan 0 liittyvässä <a href="/teht%C3%A4v%C3%A4t/#web-sovellusten-perusteet">tehtävässä 0.1</a> oli tarkoitus tutustua Mozillan <a href="https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/CSS_basics">CSS-tutoriaaliin</a>.</p>
<p>Katsotaan vielä tämän osan lopussa nopeasti erästä tapaa liittää tyylejä React-sovellukseen. Tapoja on useita ja tulemme tarkastelemaan muita myöhemmin. Liitämme nyt CSS:n sovellukseemme vanhan kansan tapaan yksittäisenä, käsin eli ilman <a href="https://developer.mozilla.org/en-US/docs/Glossary/CSS_preprocessor">esiprosessorien</a> apua kirjoitettuna tiedostona (tämä ei itseasiassa ole täysin totta, kuten myöhemmin tulemme huomaamaan).</p>
<p>Tehdään sovelluksen hakemistoon <em>src</em> tiedosto <em>index.css</em> ja liitetään se sovellukseen lisäämällä tiedostoon <em>index.js</em> seuraava import:</p>
<pre><code class="language-js">import &#x27;./index.css&#x27;;
</code></pre>
<p>Lisätään seuraava sääntö tiedostoon <em>index.css</em>:</p>
<pre><code class="language-css">h1 {
  color: green;
}
</code></pre>
<p>CSS-säännöt koostuvat valitsimesta, eli <em>selektorista</em> ja määrittelystä eli <em>deklaraatiosta</em>. Valitsin määrittelee, mihin elementteihin sääntö kohdistuu. Valitsimena on nyt <em>h1</em>, eli kaikki sovelluksessa käytetyt <em>h1</em>-otsikkotägit.</p>
<p>Määrittelyosa asettaa ominaisuuden <em>color</em>, eli fontin värin arvoksi vihreän, eli <em>green</em>.</p>
<p>Sääntö voi sisältää mielivaltaisen määrän määrittelyjä. Muutetaan edellistä siten, että tekstistä tulee kursivoitua, eli fontin tyyliksi asetetaan <em>italics</em>:</p>
<pre><code class="language-css">h1 {
  color: green;
  font-style: italic;
}
</code></pre>
<p>Erilaisia selektoreja eli tapoja valita tyylien kohde on <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors">lukuisia</a>.</p>
<p>Jos haluamme kohdistaa tyylejä esim. jokaiseen muistiinpanoon, voisimme nyt käyttää selektoria <em>li</em>, sillä muistiinpanot ovat <em>li</em>-tagien sisällä:</p>
<pre><code class="language-react">const Note = ({ note, toggleImportance}) =&gt; {
  const label = note.important ? &#x27;make not important&#x27; : &#x27;make important&#x27;
  return (
    &lt;li&gt;{note.content} &lt;button onClick={toggleImportance}&gt;{label}&lt;/button&gt;&lt;/li&gt;
  )
}
</code></pre>
<p>lisätään tyylitiedostoon seuraava (koska osaamiseni tyylikkäiden web-sivujen tekemiseen on lähellä nollaa, nyt käytettävissä tyyleissä ei ole sinänsä mitään järkeä):</p>
<pre><code class="language-css">li {
  color: grey;
  padding-top: 5px;
  font-size: 15px;
}
</code></pre>
<p>Tyylien kohdistaminen elementtityypin sijaan on kuitenkin hieman ongelmallista, jos sovelluksessa olisi myös muita <em>li</em>-tageja, kaikki saisivat samat tyylit.</p>
<p>Jos haluamme kohdistaa tyylit nimenomaan muistiinpanoihin, on parempi käyttää <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Class_selectors">class selectoreja</a>.</p>
<p>Normaalissa HTML:ssä luokat määritellään elementtien attribuutin <em>class</em> arvona:</p>
<pre><code class="language-html">&lt;li class=&quot;note&quot;&gt;tekstiä&lt;/li&gt;
</code></pre>
<p>Reactissa tulee kuitenkin classin sijaan käyttää attribuuttia <a href="https://reactjs.org/docs/dom-elements.html#classname">className</a>, eli muutetaan komponenttia <em>Note</em> seuraavasti:</p>
<pre><code class="language-react">const Note = ({ note, toggleImportance}) =&gt; {
  const label = note.important ? &#x27;make not important&#x27; : &#x27;make important&#x27;
  return (
    &lt;li className=&quot;note&quot;&gt;
      {note.content} &lt;button onClick={toggleImportance}&gt;{label}&lt;/button&gt;
    &lt;/li&gt;
  )
}
</code></pre>
<p>Luokkaselektori määritellään syntaksilla <em>.classname</em>, eli:</p>
<pre><code class="language-css">.note {
  color: grey;
  padding-top: 5px;
  font-size: 15px;
}
</code></pre>
<p>Jos nyt lisäät sovellukseen muita li-elementtejä, ne eivät saa muistiinpanoille määriteltyjä tyylejä.</p>
<h3>Parempi virheilmoitus</h3>
<p>Toteutimme äsken olemassaolemattoman muistiinpanon tärkeyden muutokseen liittyvän virheilmoituksen <em>alert</em>-metodilla. Toteutetaan se nyt Reactilla omana komponenttinaan.</p>
<p>Komponentti on yksinkertainen:</p>
<pre><code class="language-react">const Notification = ({ message }) =&gt; {
  if (message === null) {
    return null
  }
  return (
    &lt;div className=&quot;error&quot;&gt;
      {message}
    &lt;/div&gt;
  )
}
</code></pre>
<p>Jos propsin <em>message</em> arvo on <em>null</em> ei renderöidä mitään, muussa tapauksessa renderöidään viesti div-elementtiin. Elementille on liitetty tyylien lisäämistä varten luokka <em>error</em>.</p>
<p>Lisätään komponentin <em>App</em> tilaan kenttä <em>error</em> virheviestiä varten, laitetaan kentälle jotain sisältöä, jotta pääsemme heti testaamaan komponenttia:</p>
<pre><code class="language-js">class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      notes: [],
      newNote: &#x27;&#x27;,
      showAll: true,
      error: &#x27;something went wrong...&#x27;,
    };
  }
  // ...
}
</code></pre>
<p>Renderöidään uusi komponentti:</p>
<pre><code class="language-react">class App extends React.Component {
  render() {
    //...

    return (
      &lt;div&gt;
        &lt;h1&gt;Muistiinpanot&lt;/h1&gt;

        &lt;Notification message={this.state.error}/&gt;

        ...
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>Lisätään sitten virheviestille sopiva tyyli:</p>
<pre><code class="language-error">.error {
  color: red;
  background: lightgrey;
  font-size: 20px;
  border-style: solid;
  border-radius: 5px;
  padding: 10px;
  margin-bottom: 10px;
}
</code></pre>
<p>Nyt olemme valmiina lisäämään virheviestin logiikan. Alustetaan virheviesti konstruktorissa arvoon <em>null</em> ja muutetaan metodia <em>toggleImportanceOf</em> seuraavasti:</p>
<pre><code class="language-js">toggleImportanceOf = id =&gt; {
  return () =&gt; {
    //...

    noteService
      .update(id, changedNote)
      .then(changedNote =&gt; {
        // ...
      })
      .catch(error =&gt; {
        this.setState({
          error: `muistiinpano &#x27;${
            note.content
          }&#x27; on jo valitettavasti poistettu palvelimelta`,
          notes: this.state.notes.filter(n =&gt; n.id !== id),
        });
        setTimeout(() =&gt; {
          this.setState({ error: null });
        }, 5000);
      });
  };
};
</code></pre>
<p>Eli virheen yhteydessä asetetaan tilan kenttään <em>error</em> sopiva virheviesti. Samalla käynnistetään ajastin, joka asettaa 5 sekunnin kuluttua tilan <em>error</em>-kentän arvoksi <em>null</em>.</p>
<p>Lopputulos näyttää seuraavalta</p>
<picture><img style="border-color:#EB8755" alt="asd" src="/static/402de74bd283edcbf960eae5b45f6390/14be6/15b.png"/></picture>
<p>Sovelluksen tämänhetkinen koodi on kokonaisuudessaan <a href="https://github.com/FullStack-HY/part2-notes/tree/part2-7">githubissa</a>, tagissa <em>part2-7</em>.</p>
</div></div>
<div class="banner spacing spacing--after" style="background-color:#EB8755"><div class="container"><div class="course-content col-7 push-right-3">
<h3>Tehtävät 2.18</h3>
<h4>puhelinluettelo osa 11</h4>
<p>Toteuta osan 2 esimerkin <a href="/osa2/#parempi-virheilmoitus">parempi virheilmoitus</a> tyyliin ruudulla muutaman sekunnin näkyvä ilmoitus, joka kertoo onnistuneista operaatioista (henkilön lisäys ja poisto, sekä numeron muutos):</p>
<picture><img style="border-color:#EB8755" alt="asd" src="/static/e3d2a2214b222843ce8fc575c80a7b7a/14be6/17.png"/></picture>
<h3>Tehtävät 2.19*</h3>
<h4>puhelinluettelo osa 12</h4>
<p>Jos poistat jonkun henkilön toisesta selaimesta hieman ennen kun yrität <em>muuttaa henkilön numeroa</em> toisesta selaimesta, tapahtuu virhetilanne:</p>
<picture><img style="border-color:#EB8755" alt="asd" src="/static/0444c2c661bed5a4a764b2c37e928a9a/14be6/18.png"/></picture>
<p>Korjaa ongelma osan 2 esimerkin <a href="/osa2/#promise-ja-virheet">promise ja virheet</a> tapaan. Loogisin korjaus lienee henkilön lisääminen uudelleen palvelimelle. Toinen vaihtoehto on ilmoittaa käyttäjälle, että muutettavaksi yritettävän henkilön tiedot on jo poistettu.</p>
</div></div></div></div><div class="container spacing element--flex element--column element--centered"><div class="body-text "><p class="body-text__content bold">Tehtävien palautus</p></div><a href="https://studies.cs.helsinki.fi/fullstackopen/" style="padding:1rem 0" class="col-2 centered spacing--small"><div class="triple-border  triple-border--large-margin" style="padding:"><div class="triple-border__container triple-border__return-tasks" style="background-color:transparent">Palauta tehtävät palautussovellukseen</div></div></a></div><div class="container spacing spacing--after-large "><a class="push-right-1" href="/osa1"><div class=" element--flex element--column"><p style="text-align:right">Osa <!-- -->1</p><b>Edellinen osa</b></div></a><a class="push-left-1" href="/osa3"><div class=" element--flex element--column"><p>Osa <!-- -->3</p><b>Seuraava osa</b></div></a></div></div></div></div></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.page={"componentChunkName":"component---src-templates-content-template-js","jsonName":"osa-2-react-bb8","path":"/osa2/react"};window.dataPath="364/path---osa-2-react-bb-8-7c8-cgFkJ6TpyvKFqgJNSqfzUWg";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-e57bcd659185b811abbf.js"],"component---src-templates-content-template-js":["/component---src-templates-content-template-js.bb6688043828bda42216.css","/component---src-templates-content-template-js-1511b04e7342894ff772.js"],"component---src-pages-404-js":["/component---src-pages-404-js-d105615186347619f3ea.js"],"component---src-pages-about-js":["/component---src-pages-about-js.9cb33badb6596f6554cf.css","/component---src-pages-about-js-33d39daca86354262832.js"],"component---src-pages-companies-js":["/component---src-pages-companies-js-8ccc1ef3cfee87833041.js"],"component---src-pages-faq-js":["/component---src-pages-faq-js-ac90fd3ee9c727a46e04.js"],"component---src-pages-index-js":["/component---src-pages-index-js.054d4c52cecca6da6c62.css","/component---src-pages-index-js-ff419c65d16d8fc5151e.js"],"component---src-pages-osa-0-js":["/component---src-pages-osa-0-js.b8658faab52da8be69f9.css","/component---src-pages-osa-0-js-682a2c381407db664b80.js"],"component---src-pages-osa-1-js":["/component---src-pages-osa-1-js.b8658faab52da8be69f9.css","/component---src-pages-osa-1-js-cfb35b424d9c77593938.js"],"component---src-pages-osa-2-js":["/component---src-pages-osa-2-js.b8658faab52da8be69f9.css","/component---src-pages-osa-2-js-839c7c09aa8e4a4c13d9.js"],"component---src-pages-osa-3-js":["/component---src-pages-osa-3-js.b8658faab52da8be69f9.css","/component---src-pages-osa-3-js-31955868da18833a534d.js"],"component---src-pages-osa-4-js":["/component---src-pages-osa-4-js.b8658faab52da8be69f9.css","/component---src-pages-osa-4-js-088ab9adfd67fa602964.js"],"component---src-pages-osa-5-js":["/component---src-pages-osa-5-js.b8658faab52da8be69f9.css","/component---src-pages-osa-5-js-1d2b2336913251264af9.js"],"component---src-pages-osa-6-js":["/component---src-pages-osa-6-js.b8658faab52da8be69f9.css","/component---src-pages-osa-6-js-1114c8fcf3edaff242ce.js"],"component---src-pages-osa-7-js":["/component---src-pages-osa-7-js.b8658faab52da8be69f9.css","/component---src-pages-osa-7-js-e06c5739a667540a2af6.js"]};/*]]>*/</script><script src="/webpack-runtime-d71151d3c956eb7daf5e.js" async=""></script><script src="/app-e57bcd659185b811abbf.js" async=""></script><script src="/2-a8e181bf0eaee510a2de.js" async=""></script><script src="/component---src-templates-content-template-js-1511b04e7342894ff772.js" async=""></script></body></html>